<!DOCTYPE html>
<html lang="en">
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6444487225655573"
     crossorigin="anonymous"></script>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-61B7P6WEL0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-61B7P6WEL0');
</script>
  <meta charset="UTF-8" />
  <title>Flash Royale</title>
  <style>
    :root{
      --hud-bg: rgba(10,15,30,0.70);
      --hud-border:#1e3d59;
    }
    body{ margin:0; font-family:Arial, sans-serif; color:#fff; user-select:none; overflow:hidden; background:#0b0f1c; }

    /* Top HUD */
    .top-bar{
      display:flex; justify-content:space-between; align-items:center;
      padding:10px 20px; background:var(--hud-bg); border-bottom:3px solid var(--hud-border);
      font-size:14px; position:relative; z-index:3;
    }
    .currency{display:flex; gap:15px;}
    .currency div{background:#2d3e50; padding:5px 12px; border-radius:8px; display:flex; align-items:center; gap:6px;}
    #onlineCount{ margin-left:12px; font-weight:bold; }

    /* Screens */
    .screen{ display:none; height:calc(100vh - 56px); position:relative; }
    #menuScreen{ display:block; text-align:center; padding-bottom:120px; overflow:auto; }
    #battleScreen{ display:none; text-align:center; position:relative; }

    .battle-btn{
      background:#ffcc00; padding:20px 60px; border-radius:20px; font-size:32px; color:#000; cursor:pointer; margin-top:20px;
      border:3px solid #fff; box-shadow:0 0 25px rgba(255,255,0,0.9);
    }
    .cancel-btn{
      background:#ff4444; padding:15px 40px; border-radius:15px; font-size:24px; color:#fff; cursor:pointer; margin-top:20px;
      border:3px solid #fff; box-shadow:0 0 20px rgba(255,0,0,0.7); display:none;
    }

    .deck,.shop{
      display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin:20px auto; max-width:540px; position:relative; z-index:2;
    }
    .card{
      position:relative; border-radius:12px; overflow:hidden; text-align:center; font-size:12px; cursor:pointer;
      background:linear-gradient(to bottom, #2f3345, #151826); border:3px solid #889; box-shadow:0 3px 8px rgba(0,0,0,0.6); padding:8px;
    }
    .card img{ width:70%; margin:5px auto; display:block; }
    .card.selected{ border:3px solid cyan; box-shadow:0 0 15px cyan; }
    .card.cooldown{ opacity:0.45; pointer-events:none; filter:grayscale(0.5); }
    .elixir-cost{
      position:absolute; top:5px; left:5px; background:#9c27b0; border-radius:50%; width:28px; height:28px; display:flex; align-items:center; justify-content:center;
      font-size:14px; font-weight:bold; border:2px solid #fff;
    }
    .price-tag{ position:absolute; bottom:6px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.6); padding:2px 6px; border-radius:6px; font-size:12px; }
    .shop .buy-btn{ margin-top:6px; padding:6px 10px; border-radius:8px; border:2px solid #fff; background:#28a745; color:#fff; cursor:pointer; }
    .shop .buy-btn[disabled]{ opacity:.6; cursor:not-allowed; }
    .shop .owned{ margin-top:6px; padding:6px 10px; border-radius:8px; border:2px solid #888; background:#444; color:#aaa; }

    /* Procedural menu background (SVG) */
    #menuBg{ position:fixed; inset:0; z-index:0; pointer-events:none; }

    /* Arena canvas */
    #battleCanvas{
      position:relative; background:transparent; border:3px solid #fff; margin:20px auto 0; display:block; z-index:1;
    }

    /* Battle UI at bottom */
    #cardBar{
      position:fixed; bottom:100px; left:50%; transform:translateX(-50%);
      display:none; gap:10px; z-index:5;
    }
    #elixirBar{
      position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
      width:500px; height:24px; border:2px solid #fff; border-radius:10px; background:#222;
      display:none; justify-content:space-between; padding:2px; z-index:5;
    }
    .elixir-segment{ flex:1; margin:0 1px; background:#444; border-radius:4px; }
    .elixir-filled{ background:purple; }

    /* Result overlay */
    #resultScreen{
      display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8);
      color:#fff; text-align:center; font-size:32px; padding-top:200px; z-index:10;
    }
    #resultScreen button{
      margin-top:30px; padding:15px 40px; font-size:20px; border:none; border-radius:12px; cursor:pointer; background:gold; color:#000;
    }

    /* --- CHANGELOG MODAL --- */
    #changelogOverlay{
      position:fixed; inset:0; background:rgba(0,0,0,0.65);
      display:none; align-items:center; justify-content:center; z-index:20;
    }
    #changelogModal{
      width:520px; max-width:calc(100% - 40px);
      background:#111828; color:#e5e7eb;
      border:2px solid #3b82f6; border-radius:18px;
      box-shadow:0 20px 40px rgba(0,0,0,0.45);
      padding:20px 20px 14px; position:relative;
    }
    #changelogTitle{ margin:0 0 10px; font-size:20px; }
    #changelogList{ margin:0 0 8px 18px; padding:0; }
    #changelogList li{ margin:6px 0; }
    #changelogClose{
      position:absolute; top:8px; right:8px;
      width:32px; height:32px; border-radius:50%;
      border:2px solid #93c5fd; background:#1f2937; color:#e5e7eb;
      font-size:18px; line-height:26px; cursor:pointer;
    }
    #changelogClose:hover{ background:#374151; }
    #changelogHint{ opacity:0.7; font-size:12px; }

    /* --- LEADERBOARD (RIGHT) --- */
    .leaderboard{
      position:fixed;
      right:20px;
      top:90px; bottom:20px;
      width:360px;
      overflow:auto;
      text-align:left;
      background:rgba(17,24,39,0.85);
      border:2px solid #334155; border-radius:16px;
      box-shadow:0 8px 24px rgba(0,0,0,0.35);
      z-index:2;
    }
    .leaderboard h3{
      margin:0; padding:12px 16px; background:#0f172a; border-bottom:2px solid #334155; font-size:18px;
    }
    .lb-row{ display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-bottom:1px solid rgba(255,255,255,0.07); }
    .lb-row:nth-child(odd){ background:rgba(255,255,255,0.02); }
    .lb-rank{ width:36px; text-align:center; font-weight:bold; }
    .lb-name{ flex:1; padding:0 8px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .lb-trophies{ min-width:90px; text-align:right; font-weight:bold; }

    /* === Dancing avatars (menu only) === */
    #dancerStage{
      position: fixed;
      left: 20px;
      right: 400px;          /* keep clear of the leaderboard */
      bottom: 20px;
      display: flex;
      gap: 14px;
      align-items: flex-end;
      pointer-events: none;  /* never block clicks */
      z-index: 1;            /* below leaderboard (z:2) and HUD (z:3) */
    }
    .dancer{
      position: relative;
      width: 64px; height: 64px;
      border-radius: 50%;
      background: radial-gradient(60% 60% at 50% 35%, #374151 0%, #0f172a 70%);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35), inset 0 0 12px rgba(59,130,246,0.25);
      display: flex; align-items: center; justify-content: center;
      animation: bob 1.8s ease-in-out infinite;
      animation-delay: var(--delay, 0s);
    }
    .dancer span{
      font-size: 34px; line-height: 1;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.45));
      animation: wiggle 1.4s ease-in-out infinite;
      animation-delay: calc(var(--delay, 0s) * 1.15);
    }
    .dancer::after{
      content: "";
      position: absolute;
      bottom: -6px; left: 50%; transform: translateX(-50%);
      width: 40px; height: 8px; border-radius: 50%;
      background: rgba(0,0,0,0.28);
      filter: blur(2px);
      animation: shadowPulse 1.8s ease-in-out infinite;
      animation-delay: var(--delay, 0s);
    }
    @keyframes bob{
      0%{   transform: translateY(0) rotate(0deg); }
      50%{  transform: translateY(-10px) rotate(-2deg); }
      100%{ transform: translateY(0) rotate(0deg); }
    }
    @keyframes wiggle{
      0%{   transform: rotate(0deg); }
      25%{  transform: rotate(-8deg); }
      50%{  transform: rotate(0) scale(1.04); }
      75%{  transform: rotate(8deg); }
      100%{ transform: rotate(0); }
    }
    @keyframes shadowPulse{
      0%{   transform: translateX(-50%) scale(1);    opacity: .6; }
      50%{  transform: translateX(-50%) scale(0.85); opacity: .4; }
      100%{ transform: translateX(-50%) scale(1);    opacity: .6; }
    }

    /* === Manual panel (menu only, LEFT) === */
    #manualPanel{
      position: fixed;
      left: 20px;
      top: 90px;
      bottom: 220px;              /* leaves visual space for dancers near bottom */
      width: 360px;
      overflow: auto;
      text-align: left;
      background: rgba(17,24,39,0.85);
      border: 2px solid #334155;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      z-index: 2;
      padding-bottom: 10px;
    }
    #manualPanel h3{
      margin:0; padding:12px 16px; background:#0f172a; border-bottom:2px solid #334155; font-size:18px;
    }
    #manualPanel .section{
      padding:10px 16px 4px;
      border-bottom:1px dashed rgba(255,255,255,0.08);
    }
    #manualPanel .section:last-child{ border-bottom:none; }
    #manualPanel ul{ margin:6px 0 6px 18px; padding:0; }
    #manualPanel li{ margin:4px 0; line-height:1.35; }
    #manualPanel .kbd{
      display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.2);
      background:#0b1220; font-size:12px;
    }
    @media (max-width: 1100px){
      #manualPanel{ display:none; }
      #dancerStage{ display:none; }
    }
    @media (max-height: 700px){
      #manualPanel{ bottom: 140px; }
    }

    /* === STARTING SPLASH (Click to Play) === */
    #startOverlay{
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        linear-gradient(rgba(0,0,0,0.35), rgba(0,0,0,0.55)),
        url('startinglayer.png') center center / cover no-repeat;
      cursor: pointer;
    }
    #startOverlay .startText{
      font-size: 42px;
      font-weight: 800;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.55);
      padding: 14px 26px;
      border: 2px solid #fff;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      text-shadow: 0 2px 12px rgba(255,255,255,0.25);
      user-select: none;
      -webkit-user-select: none;
      animation: pulseText 1.6s ease-in-out infinite;
    }
    @keyframes pulseText{
      0%{ transform: scale(1); opacity: 1; }
      50%{ transform: scale(1.05); opacity: 0.92; }
      100%{ transform: scale(1); opacity: 1; }
    }
  </style>

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
</head>
<body>
  <!-- Background music (loop) — ADDED -->
  <audio id="bgm" src="mixkit-the-boss-479.mp3" loop preload="auto" playsinline></audio>

  <!-- STARTING SPLASH (Click to Play) -->
  <div id="startOverlay" title="Click to Play">
    <div class="startText">Click to Play</div>
  </div>

  <!-- Top HUD -->
  <div class="top-bar">
    <div class="currency">
      <div><img src="https://img.icons8.com/emoji/48/000000/coin-emoji.png" width="18" height="18"/> <span id="coinCount">0</span></div>
    </div>
    <div>
      <span id="statusText">Idle</span>
      <span id="onlineCount">Online: 0</span>
    </div>
  </div>

  <!-- MENU BACKGROUND (BUILT-IN) -->
  <svg id="menuBg" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice">
    <defs>
      <linearGradient id="sky" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#0b1228"/>
        <stop offset="60%" stop-color="#0b0f1c"/>
        <stop offset="100%" stop-color="#09101e"/>
      </linearGradient>
      <linearGradient id="mist" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#1c2444" stop-opacity="0.0"/>
        <stop offset="100%" stop-color="#1c2444" stop-opacity="0.35"/>
      </linearGradient>
      <linearGradient id="ground" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#0d1a2b"/>
        <stop offset="100%" stop-color="#0a1524"/>
      </linearGradient>
    </defs>
    <rect width="1920" height="1080" fill="url(#sky)"/>
    <path d="M0,720 C300,640 500,700 800,660 C1150,610 1450,690 1920,620 L1920,1080 L0,1080 Z" fill="#0c162e"/>
    <path d="M0,760 C350,700 550,760 850,740 C1200,710 1500,760 1920,700 L1920,1080 L0,1080 Z" fill="#0e1a35"/>
    <rect y="650" width="1920" height="430" fill="url(#mist)"/>
    <g transform="translate(960,520) scale(1.0)" fill="#1a2748" opacity="0.9">
      <rect x="-260" y="-60" width="520" height="200"/>
      <rect x="-330" y="-150" width="70" height="290"/><rect x="-330" y="-190" width="70" height="40"/>
      <rect x="260" y="-150" width="70" height="290"/><rect x="260" y="-190" width="70" height="40"/>
      <rect x="-90" y="-220" width="180" height="360"/><polygon points="-90,-220 0,-320 90,-220"/>
      <g>
        <rect x="-260" y="-60" width="30" height="30"/><rect x="-210" y="-60" width="30" height="30"/>
        <rect x="-160" y="-60" width="30" height="30"/><rect x="-110" y="-60" width="30" height="30"/>
        <rect x="-60" y="-60" width="30" height="30"/><rect x="-10" y="-60" width="30" height="30"/>
        <rect x="40" y="-60" width="30" height="30"/><rect x="90" y="-60" width="30" height="30"/>
        <rect x="140" y="-60" width="30" height="30"/><rect x="190" y="-60" width="30" height="30"/>
        <rect x="240" y="-60" width="30" height="30"/>
      </g>
    </g>
    <rect y="800" width="1920" height="280" fill="url(#ground)"/>
  </svg>

  <!-- MENU -->
  <div id="menuScreen" class="screen">
    <h2>🏆 Flash Royale</h2>
    <p>Name: <b id="playerNameLabel"></b></p>
    <p>Your trophies: <b id="trophies">0</b></p>

    <button id="battleBtn" class="battle-btn" onclick="findMatch()">BATTLE</button>
    <button id="cancelBtn" class="cancel-btn" onclick="cancelSearch()">Cancel</button>

    <h2>Your Deck</h2>
    <div class="deck" id="deck"></div>

    <h2>Shop</h2>
    <div class="shop" id="shop"></div>

    <!-- GLOBAL LEADERBOARD (menu-only, right side) -->
    <div class="leaderboard" id="leaderboard">
      <h3>🌍 Global Leaderboard (Trophies)</h3>
      <div id="leaderboardRows"></div>
    </div>

    <!-- Manual panel (menu-only, LEFT) -->
    <aside id="manualPanel" aria-label="Game Manual">
      <h3>📖 Quick Manual</h3>

      <div class="section">
        <strong>How to Start</strong>
        <ul>
          <li>Hit <span class="kbd">BATTLE</span> to join the queue. The game makes strict 1v1 rooms—two per room, multiple rooms supported.</li>
          <li>If no one’s ready yet, you’ll see <em>Searching…</em> until another player joins.</li>
          <li>Your name (filtered) shows near your king tower.</li>
        </ul>
      </div>

      <div class="section">
        <strong>Placing Units</strong>
        <ul>
          <li>Click a card in your hand, then click anywhere on <em>your half</em> of the arena. A white circle follows your cursor before placing.</li>
          <li><b>Units fight enemy troops first.</b> If no enemies are nearby, they head to the nearest bridge, cross, then push toward enemy towers.</li>
          <li>Both players see each other’s placements and damage in real time.</li>
        </ul>
      </div>

      <div class="section">
        <strong>Elixir & Cards</strong>
        <ul>
          <li>Elixir bar holds 10 segments; you gain +1 every 2 seconds (max 10).</li>
          <li>Cards cost elixir; if you don’t have enough, you can’t place them.</li>
          <li>Used cards have a 5s cooldown before you can select them again.</li>
        </ul>
      </div>

      <div class="section">
        <strong>Towers & Win</strong>
        <ul>
          <li>Two side towers + one king tower per side. Towers shoot back automatically.</li>
          <li>Destroy the opponent’s king tower to win the match.</li>
          <li>Win rewards: +100 coins, +5 trophies.</li>
        </ul>
      </div>

      <div class="section">
        <strong>Shop & Coins</strong>
        <ul>
          <li>Earn coins from wins and buy new characters in the shop.</li>
          <li>Everyone starts with 400 coins and a few starter cards.</li>
        </ul>
      </div>

      <div class="section">
        <strong>Reconnect & Cleanup</strong>
        <ul>
          <li>If you refresh or disconnect, you can rejoin your active room.</li>
          <li>Rooms auto-delete when the game ends or both players go inactive.</li>
          <li>Leaderboard on the right shows global trophies (top 20).</li>
        </ul>
      </div>

      <div class="section">
        <strong>Controls</strong>
        <ul>
          <li><span class="kbd">Click</span> a card to select.</li>
          <li><span class="kbd">Click</span> on your half of the arena to place.</li>
        </ul>
      </div>
    </aside>

    <!-- Dancing Avatars (menu only) -->
    <div id="dancerStage" aria-hidden="true">
      <div class="dancer" style="--delay:0.00s"><span>🕺</span></div>
      <div class="dancer" style="--delay:0.12s"><span>💃</span></div>
      <div class="dancer" style="--delay:0.24s"><span>🧙‍♂️</span></div>
      <div class="dancer" style="--delay:0.36s"><span>🧝‍♀️</span></div>
      <div class="dancer" style="--delay:0.48s"><span>🛡️</span></div>
      <div class="dancer" style="--delay:0.60s"><span>🐲</span></div>
    </div>
  </div>

  <!-- BATTLE -->
  <div id="battleScreen" class="screen">
    <canvas id="battleCanvas" width="800" height="700"></canvas>
  </div>

  <!-- Battle UI -->
  <div id="cardBar"></div>
  <div id="elixirBar"></div>

  <!-- Result -->
  <div id="resultScreen">
    <h1 id="resultText"></h1>
    <p id="rewardText"></p>
    <button onclick="returnToMenu()">OK</button>
  </div>

  <!-- CHANGELOG MODAL -->
  <div id="changelogOverlay" role="dialog" aria-modal="true" aria-labelledby="changelogTitle">
    <div id="changelogModal">
      <button id="changelogClose" aria-label="Close changelog">×</button>
      <h3 id="changelogTitle">What’s new in Flash Royale</h3>
      <ul id="changelogList">
        <li>Scripted and brought to you by Chace, enjoy!</li>
        <li><b>NEW:</b> Units now target and fight enemy troops before going for towers.</li>
        <li>Units cross bridges; tower AI shoots back; health bars on towers &amp; units.</li>
        <li>Strict 1v1 matchmaking with multiple simultaneous rooms.</li>
        <li>Elixir bar (10 segments, +1 per 2s), 5s card cooldown after use.</li>
        <li>Shop with 24 characters; +100 coins &amp; +5 trophies on win.</li>
        <li>Rejoin after refresh; rooms auto-clean when both players leave.</li>
        <li>Player names shown by king castles; placement only on your half.</li>
      </ul>
      <div id="changelogHint">Click × to close</div>
    </div>
  </div>

  <script>
    /************ Firebase Init ************/
    const firebaseConfig = {
      apiKey: "AIzaSyA3FUH9RZiQ9IRChNpGqNrgjt2r5AA5RF8",
      authDomain: "flash-royale-a92c0.firebaseapp.com",
      databaseURL: "https://flash-royale-a92c0-default-rtdb.firebaseio.com",
      projectId: "flash-royale-a92c0",
      storageBucket: "flash-royale-a92c0.appspot.com",
      messagingSenderId: "703977930640",
      appId: "1:703977930640:web:a4f70deb5bbe508aec7d15",
      measurementId: "G-61B7P6WEL0"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    /************ Name Filter ************/
    function normalizeForFilter(s){
      if(!s) return "";
      s = (""+s).toLowerCase();
      const map = {'0':'o','1':'i','!':'i','3':'e','4':'a','@':'a','$':'s','5':'s','7':'t','8':'b','9':'g'};
      s = s.replace(/[0!134@5$789]/g, ch => map[ch] || ch);
      s = s.replace(/[^a-z0-9]/g, "");
      s = s.replace(/([a-z0-9])\1{1,}/g, "$1$1");
      return s;
    }
    const bannedB64 = [
      "ZnVjaw==","c2hpdA==","Yml0Y2g=","Y3VudA==","ZGljaw==","cHVzc3k=","YXNz","YXNzaG9sZQ==","YmFzdGFyZA==",
      "ZGFtbg==","c3Vja2Vy","c2x1dA==","Z2F5","bmF6aQ==","Y3JhcA==","YmVhbg==","cmlt","a2lsbA=="
    ];
    const bannedWords = bannedB64.map(b => atob(b));
    function containsBannedWord(name){
      const n = normalizeForFilter(name);
      if(!n) return false;
      for(const w of bannedWords){ if(n.includes(w)) return true; }
      return false;
    }
    function sanitizeNameBasic(s){ return (s||"").replace(/[^a-zA-Z0-9]/g,"").substring(0,6); }
    function requestCleanName(){
      for(let i=0;i<3;i++){
        const raw = prompt("Enter your player name (max 6 letters/numbers):","");
        const cleaned = sanitizeNameBasic(raw);
        if(cleaned && !containsBannedWord(cleaned)) return cleaned;
        alert("That name isn't allowed. Please choose another.");
      }
      return "Anon";
    }

    /************ Player & Presence ************/
    let playerId = localStorage.getItem("playerId");
    if(!playerId){ playerId="player-"+Math.floor(Math.random()*10000); localStorage.setItem("playerId",playerId); }

    let playerName = localStorage.getItem("playerName");
    if(!playerName){
      playerName = requestCleanName();
      localStorage.setItem("playerName",playerName);
    }else{
      if(containsBannedWord(playerName) || !/^[a-zA-Z0-9]{1,6}$/.test(playerName)){
        playerName = requestCleanName();
        localStorage.setItem("playerName",playerName);
      }
    }
    document.getElementById("playerNameLabel").innerText = playerName;

    const playerRef = db.ref("players/"+playerId);

    // Initialize if missing; start with 400 coins
    playerRef.once("value").then(snap=>{
      if(!snap.exists()){
        playerRef.set({
          name: playerName, online: true, disconnected: false,
          coins: 400, trophies: 0,
          ownedCards: { "Knight": true, "Archer": true, "Golem": true, "Dragon": true }
        });
      } else {
        const p = snap.val()||{};
        const updates = { name:playerName, online:true, disconnected:false };
        if(p.coins===undefined || p.coins===null) updates.coins = 400;
        playerRef.update(updates);
      }
    });

    // HUD sync
    playerRef.on("value", s=>{
      const p = s.val()||{};
      document.getElementById("coinCount").innerText = p.coins||0;
      document.getElementById("trophies").innerText = p.trophies||0;
    });

    // Online count
    db.ref("players").on("value", snap=>{
      let online=0; snap.forEach(c=>{ if(c.val() && c.val().online) online++; });
      document.getElementById("onlineCount").innerText = "Online: "+online;
    });

    // Presence flags
    playerRef.onDisconnect().update({ online:false, disconnected:true });

    /************ Cards (24 total) ************/
    const allCards = [
      {name:"Knight",hp:200,maxHp:200,dmg:20,range:25,cost:3,speed:2,img:"https://img.icons8.com/color/96/knight.png", price:0},
      {name:"Archer",hp:120,maxHp:120,dmg:15,range:120,cost:3,speed:2,img:"https://img.icons8.com/color/96/bow.png", price:0},
      {name:"Golem",hp:400,maxHp:400,dmg:30,range:25,cost:6,speed:1,img:"https://img.icons8.com/color/96/rock.png", price:0},
      {name:"Dragon",hp:150,maxHp:150,dmg:40,range:100,cost:5,speed:3,img:"https://img.icons8.com/color/96/dragon.png", price:0},

      {name:"Wizard",hp:160,maxHp:160,dmg:35,range:150,cost:5,speed:2,img:"https://img.icons8.com/color/96/wizard.png", price:500},
      {name:"Goblin",hp:90,maxHp:90,dmg:12,range:25,cost:2,speed:4,img:"https://img.icons8.com/color/96/goblin.png", price:200},
      {name:"Barbarian",hp:220,maxHp:220,dmg:25,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/barbarian.png", price:400},
      {name:"Ice Spirit",hp:80,maxHp:80,dmg:10,range:20,cost:1,speed:5,img:"https://img.icons8.com/color/96/snowflake.png", price:150},
      {name:"Giant",hp:600,maxHp:600,dmg:45,range:25,cost:7,speed:1,img:"https://img.icons8.com/color/96/giant.png", price:700},
      {name:"Musketeer",hp:140,maxHp:140,dmg:30,range:200,cost:4,speed:2,img:"https://img.icons8.com/color/96/musket.png", price:450},
      {name:"Prince",hp:280,maxHp:280,dmg:50,range:25,cost:5,speed:3,img:"https://img.icons8.com/color/96/prince.png", price:600},
      {name:"Dark Knight",hp:260,maxHp:260,dmg:35,range:30,cost:5,speed:3,img:"https://img.icons8.com/color/96/darth-vader.png", price:600},
      {name:"Healer",hp:150,maxHp:150,dmg:0,range:60,cost:4,speed:2,img:"https://img.icons8.com/color/96/angel.png", price:400},
      {name:"Bomber",hp:110,maxHp:110,dmg:45,range:60,cost:3,speed:2,img:"https://img.icons8.com/color/96/bomb.png", price:300},
      {name:"Skeleton Army",hp:50,maxHp:50,dmg:10,range:20,cost:3,speed:4,img:"https://img.icons8.com/color/96/skeleton.png", price:250},
      {name:"Valkyrie",hp:260,maxHp:260,dmg:40,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/valkyrie.png", price:450},
      {name:"Hog Rider",hp:280,maxHp:280,dmg:55,range:25,cost:4,speed:4,img:"https://img.icons8.com/color/96/boar.png", price:500},
      {name:"Electro Spirit",hp:100,maxHp:100,dmg:20,range:60,cost:2,speed:4,img:"https://img.icons8.com/color/96/lightning-bolt.png", price:250},
      {name:"Baby Dragon",hp:180,maxHp:180,dmg:35,range:80,cost:4,speed:3,img:"https://img.icons8.com/color/96/baby-dragon.png", price:500},
      {name:"Pekka",hp:700,maxHp:700,dmg:80,range:25,cost:8,speed:1,img:"https://img.icons8.com/color/96/robot.png", price:800},
      {name:"Bandit",hp:200,maxHp:200,dmg:40,range:25,cost:4,speed:5,img:"https://img.icons8.com/color/96/ninja.png", price:500},
      {name:"Witch",hp:160,maxHp:160,dmg:25,range:180,cost:5,speed:2,img:"https://img.icons8.com/color/96/witch.png", price:500},
      {name:"Bowler",hp:300,maxHp:300,dmg:35,range:150,cost:6,speed:2,img:"https://img.icons8.com/color/96/bowling-ball.png", price:600},
      {name:"Hunter",hp:200,maxHp:200,dmg:50,range:100,cost:4,speed:3,img:"https://img.icons8.com/color/96/shotgun.png", price:500},
      {name:"Mega Minion",hp:140,maxHp:140,dmg:30,range:50,cost:3,speed:3,img:"https://img.icons8.com/color/96/minion.png", price:350}
    ];

    /* Deck + Shop render */
    function renderDeck(owned){
      const deckEl = document.getElementById("deck");
      deckEl.innerHTML="";
      allCards.forEach(c=>{
        if(!owned || owned[c.name]){
          const d=document.createElement("div");
          d.className="card";
          d.innerHTML=`<div class="elixir-cost">${c.cost}</div><img src="${c.img}"><b>${c.name}</b>`;
          deckEl.appendChild(d);
        }
      });
    }
    function renderShop(owned, coins){
      const shop = document.getElementById("shop"); shop.innerHTML="";
      allCards.forEach(c=>{
        if(c.price<=0) return;
        const ownedFlag = !!owned[c.name];
        const el = document.createElement("div");
        el.className="card";
        el.innerHTML = `
          <div class="elixir-cost">${c.cost}</div>
          <img src="${c.img}">
          <b>${c.name}</b>
          <div class="price-tag">${c.price} 🪙</div>
          <button class="${ownedFlag?'owned':'buy-btn'}" ${ownedFlag?'disabled':''}>${ownedFlag?'Owned':'Buy'}</button>
        `;
        if(!ownedFlag){
          const btn = el.querySelector('.buy-btn');
          btn.onclick = ()=>{
            btn.disabled = true; btn.textContent = "Buying...";
            playerRef.child("coins").transaction(v=>{
              v=v||0; if(v < c.price) return; return v - c.price;
            }, (err, committed)=>{
              if(err || !committed){
                btn.disabled=false; btn.textContent="Buy";
                alert("Not enough coins or network error.");
                return;
              }
              playerRef.child("ownedCards/"+c.name).set(true);
            });
          };
        }
        shop.appendChild(el);
      });
    }
    playerRef.on("value", s=>{
      const p=s.val()||{}; const owned=p.ownedCards||{};
      renderDeck(owned); renderShop(owned, p.coins||0);
    });

    /************ Elixir ************/
    let elixir=0, maxElixir=10, elixirRegenRate=2000, lastElixirTime=Date.now();
    function initElixirBar(){
      const bar=document.getElementById("elixirBar"); bar.innerHTML="";
      for(let i=0;i<maxElixir;i++){ const seg=document.createElement("div"); seg.className="elixir-segment"; seg.id="elixir-"+i; bar.appendChild(seg); }
    }
    function updateElixir(){
      const now=Date.now();
      if(now-lastElixirTime>=elixirRegenRate && elixir<maxElixir){ elixir++; lastElixirTime=now; }
      for(let i=0;i<maxElixir;i++){ const seg=document.getElementById("elixir-"+i); if(seg) seg.classList.toggle("elixir-filled", i<elixir); }
    }
    setInterval(updateElixir, 200);

    /************ Matchmaking (strict 1v1; multiple rooms) ************/
    let roomId=null, mySide=null, searching=false, battleReady=false, isHost=false, hostId=null;
    let roomRef=null, actionsRef=null, stateRef=null, roomPlayersRef=null, queueAdded=false, pairInterval=null;

    function findMatch(){
      document.getElementById("statusText").innerText="Searching...";
      document.getElementById("battleBtn").style.display="none";
      document.getElementById("cancelBtn").style.display="inline-block";
      searching=true;

      const myQueueRef = db.ref("queue/"+playerId);
      if(!queueAdded){
        myQueueRef.set({ name:playerName, ts:firebase.database.ServerValue.TIMESTAMP, searching:true });
        myQueueRef.onDisconnect().remove();
        queueAdded=true;
      }
      attemptPair();
      if(pairInterval) clearInterval(pairInterval);
      pairInterval = setInterval(()=>{ if(searching && !roomId) attemptPair(); }, 1500);

      db.ref("rooms").on("child_added", snap=>{
        if(!searching || roomId) return;
        const r=snap.val();
        if(r && r.players && r.players[playerId]){
          roomId=snap.key;
          mySide = r.players[playerId].side || "red";
          startBattle();
        }
      });
    }

    function attemptPair(){
      db.ref("queue").once("value").then(snap=>{
        if(!searching || roomId) return;
        const q = snap.val()||{};
        let cand=null, bestTs=Infinity;
        Object.keys(q).forEach(k=>{
          if(k===playerId) return;
          const it=q[k]; if(!it || it.claimed) return;
          const ts = typeof it.ts==='number' ? it.ts : Date.now();
          if(ts<bestTs){ bestTs=ts; cand=k; }
        });
        if(!cand) return;

        db.ref("queue/"+cand+"/claimed").transaction(val=>{
          if(val) return; return playerId;
        }, async (err, committed, snap2)=>{
          if(err || !committed || snap2.val()!==playerId){ return; }
          const oppNameSnap = await db.ref("players/"+cand+"/name").once("value");
          const oppName = oppNameSnap.val() || "Opponent";

          roomId = "room-"+Date.now()+"-"+Math.floor(Math.random()*1000);
          mySide = "blue";
          const roomData={
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            state:"active",
            host: playerId,
            players:{
              [playerId]:{connected:true,side:"blue",name:playerName},
              [cand]:{connected:true,side:"red",name:oppName}
            }
          };
          db.ref("rooms/"+roomId).set(roomData).then(()=>{
            db.ref("queue/"+cand).remove();
            db.ref("queue/"+playerId).remove();
            startBattle();
          });
        });
      });
    }

    function cancelSearch(){
      searching=false;
      if(pairInterval){ clearInterval(pairInterval); pairInterval=null; }
      db.ref("queue/"+playerId).remove();
      queueAdded=false;
      document.getElementById("statusText").innerText="Idle";
      document.getElementById("battleBtn").style.display="inline-block";
      document.getElementById("cancelBtn").style.display="none";
    }

    function tryRejoinRoom(){
      db.ref("rooms").once("value").then(s=>{
        s.forEach(r=>{
          const val=r.val();
          if(val && val.state==="active" && val.players && val.players[playerId]){
            roomId=r.key; mySide=val.players[playerId].side||"red";
            startBattle();
          }
        });
      });
    }
    playerRef.once("value").then(s=>{
      const p=s.val()||{};
      if(p.disconnected){ tryRejoinRoom(); playerRef.update({disconnected:false, online:true}); }
    });

    /************ Battle ************/
    const canvas=document.getElementById("battleCanvas");
    const ctx=canvas.getContext("2d");
    const towerImg=new Image(); towerImg.src="mini-castle.png";

    // Arena geometry (pathing)
    const RIVER_H = 40;
    const BRIDGE_W = 140;
    const RIVER_Y = canvas.height/2 - RIVER_H/2;
    const BRIDGE_CENTERS = [220, 580]; // x centers

    // State
    let towers=[], units=[], selectedCard=null;
    let placementCircle=null, lastMouse={x:canvas.width/2, y:canvas.height*0.75};
    const cardCooldowns={}; // name -> timestamp
    let projectiles=[]; // tower shots
    let gameOver=false;
    let nameBlue="Blue", nameRed="Red";
    let pendingActionKeys=new Set();
    let lastPublishTime=0, PUBLISH_MS=100;
    let roomCleanupArmed=true;

    // Hand (owned cards)
    function renderHand(owned){
      const bar=document.getElementById("cardBar"); bar.innerHTML="";
      allCards.forEach(card=>{
        if(!owned[card.name]) return;
        const d=document.createElement("div"); d.className="card";
        d.innerHTML=`<div class="elixir-cost">${card.cost}</div><img src="${card.img}"><b>${card.name}</b>`;
        const now=Date.now(); const cd=cardCooldowns[card.name]||0;
        if(cd>now) d.classList.add("cooldown");
        d.onclick=()=>{
          if((cardCooldowns[card.name]||0) > Date.now()) return;
          selectedCard=card;
          document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
          d.classList.add("selected");
          let y=lastMouse.y;
          if(mySide==="blue" && y<canvas.height/2) y=canvas.height/2;
          if(mySide==="red"  && y>canvas.height/2) y=canvas.height/2;
          placementCircle={x:lastMouse.x, y};
        };
        bar.appendChild(d);
      });
    }
    function refreshCooldownStyles(){
      const now=Date.now();
      document.querySelectorAll("#cardBar .card").forEach(el=>{
        const nameEl=el.querySelector("b"); if(!nameEl) return;
        const nm=nameEl.textContent;
        el.classList.toggle("cooldown", (cardCooldowns[nm]||0) > now);
      });
    }

    function clampToHalf(x,y){
      if(mySide==="blue" && y<canvas.height/2) y=canvas.height/2;
      if(mySide==="red"  && y>canvas.height/2) y=canvas.height/2;
      if(x<20) x=20; if(x>canvas.width-20) x=canvas.width-20;
      if(y<20) y=20; if(y>canvas.height-20) y=canvas.height-20;
      return {x,y};
    }
    canvas.addEventListener("mousemove", e=>{
      const r=canvas.getBoundingClientRect();
      lastMouse.x = e.clientX - r.left;
      lastMouse.y = e.clientY - r.top;
      if(!selectedCard){ placementCircle=null; return; }
      placementCircle = clampToHalf(lastMouse.x, lastMouse.y);
    });

    // Drop card → push action
    canvas.addEventListener("click", e=>{
      if(!battleReady) return;
      if(!selectedCard) return;
      const rect=canvas.getBoundingClientRect();
      let x=e.clientX-rect.left, y=e.clientY-rect.top;
      ({x,y}=clampToHalf(x,y));
      if(elixir < selectedCard.cost) return;

      elixir -= selectedCard.cost;
      cardCooldowns[selectedCard.name]=Date.now()+5000;
      refreshCooldownStyles();

      db.ref("rooms/"+roomId+"/actions").push({
        player:playerId, card:selectedCard, x, y, timestamp:Date.now()
      });

      selectedCard=null; placementCircle=null;
      document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
    });

    /* Drawing helpers */
    function drawArena(){
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,"#0f2b1f"); g.addColorStop(0.5,"#123725"); g.addColorStop(1,"#0f2b1f");
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle="#243a5e";
      ctx.fillRect(0, RIVER_Y, canvas.width, RIVER_H);

      const bridges=[ {x:BRIDGE_CENTERS[0]-BRIDGE_W/2, y:RIVER_Y-6}, {x:BRIDGE_CENTERS[1]-BRIDGE_W/2, y:RIVER_Y-6} ];
      ctx.fillStyle="#6e5537";
      bridges.forEach(b=>{
        ctx.fillRect(b.x, b.y, BRIDGE_W, RIVER_H+12);
        ctx.fillStyle="#7a6040";
        for(let i=0;i<BRIDGE_W;i+=18){ ctx.fillRect(b.x+i+2, b.y, 8, RIVER_H+12); }
        ctx.fillStyle="#6e5537";
      });

      ctx.strokeStyle="rgba(255,255,255,0.15)"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0, canvas.height/3); ctx.lineTo(canvas.width, canvas.height/3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, canvas.height*2/3); ctx.lineTo(canvas.width, canvas.height*2/3); ctx.stroke();

      ctx.fillStyle="rgba(0,0,255,0.05)"; ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
      ctx.fillStyle="rgba(255,0,0,0.05)"; ctx.fillRect(0, 0, canvas.height/2, canvas.height/2);
      ctx.fillStyle="rgba(255,0,0,0.05)"; ctx.fillRect(0, 0, canvas.width, canvas.height/2);
    }

    function drawTower(t){
      const size = t.king ? 60 : 50;
      if(towerImg.complete){ ctx.drawImage(towerImg, t.x-size/2, t.y-size/2, size, size); }
      else{ ctx.fillStyle=t.side==="blue"?"#5ec8ff":"#ff6b6b"; ctx.fillRect(t.x-size/2, t.y-size/2, size, size); }
      const maxHp = t.king?1000:600;
      ctx.fillStyle="#900"; ctx.fillRect(t.x-28, t.y-(size/2)-10, 56, 6);
      ctx.fillStyle="#3f3"; ctx.fillRect(t.x-28, t.y-(size/2)-10, 56*(Math.max(0,t.hp)/maxHp), 6);
    }
    function drawTowerName(t, nm){
      if(!nm) return;
      ctx.font='16px Arial'; ctx.textAlign='center'; ctx.lineWidth=3; ctx.strokeStyle='black';
      const size = t.king ? 60 : 50;
      const y = t.side==='blue' ? (t.y + size/2 + 18) : (t.y - size/2 - 14);
      ctx.strokeText(nm, t.x, y);
      ctx.fillStyle='white'; ctx.fillText(nm, t.x, y);
    }

    function drawUnit(u){
      ctx.fillStyle = (u.side==="blue") ? "#8de1ff" : "#ff7f7f";
      ctx.beginPath(); ctx.arc(u.x, u.y, 14, 0, Math.PI*2); ctx.fill();
      const step = Math.sin(Date.now()/120)*4;
      ctx.strokeStyle=(u.side==="blue")?"#c7f1ff":"#ffd1d1"; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(u.x-8, u.y+14); ctx.lineTo(u.x-8, u.y+20+step); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(u.x+8, u.y+14); ctx.lineTo(u.x+8, u.y+20-step); ctx.stroke();
      ctx.fillStyle="#900"; ctx.fillRect(u.x-15, u.y-24, 30, 5);
      ctx.fillStyle="#3f3"; ctx.fillRect(u.x-15, u.y-24, 30*(u.hp/u.maxHp), 5);
    }

    /************ Simulation (host-only) ************/
    function pickNearestBridgeX(x){
      const a=BRIDGE_CENTERS[0], b=BRIDGE_CENTERS[1];
      return (Math.abs(x-a) <= Math.abs(x-b)) ? a : b;
    }

    function nearestEnemyTower(u){
      let best=null, bestD2=Infinity;
      for(const t of towers){
        if(t.side===u.side || t.hp<=0) continue;
        const dx=t.x - u.x, dy=t.y - u.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < bestD2){ best=t; bestD2=d2; }
      }
      return best;
    }

    /* NEW: find nearest enemy unit (within radius) */
    function nearestEnemyUnit(u, radius){
      let best=null, bestD2=radius*radius;
      for(const other of units){
        if(other===u) continue;
        if(other.side===u.side) continue;
        if(other.hp<=0) continue;
        const dx=other.x - u.x, dy=other.y - u.y;
        const d2 = dx*dx + dy*dy;
        if(d2 <= bestD2){ best=other; bestD2=d2; }
      }
      return best;
    }

    function spawnUnit(card, side, x, y){
      const slowFactor = 0.30; // slower
      const speed = Math.max(0.35, card.speed * slowFactor);
      const bridgeX = pickNearestBridgeX(x);
      const startTargetY = side==='blue' ? (RIVER_Y + RIVER_H + 8) : (RIVER_Y - 8);
      units.push({
        name:card.name, hp:card.hp, maxHp:card.maxHp, dmg:card.dmg, range:card.range,
        speed, side, x, y, cooldown:0, dir:(side==="blue" ? -1 : 1),
        pathStage:'toBridge', targetX: bridgeX, targetY: startTargetY,
        goal: null,           // tower target (fallback)
        goalUnit: null        // NEW: enemy unit target (preferred)
      });
    }

    function moveTowards(u, tx, ty){
      const dx=tx-u.x, dy=ty-u.y;
      const dist = Math.hypot(dx,dy);
      if(dist <= u.speed){ u.x=tx; u.y=ty; return true; }
      u.x += u.speed * dx/dist;
      u.y += u.speed * dy/dist;
      return false;
    }

    /* UPDATED: units fight units first, then towers */
    function updateUnits(){
      const AGGRO_PAD = 20; // detection a bit larger than attack range
      const DROP_MULT = 1.3; // how far a locked target can wander before we drop it

      units.forEach(u=>{
        const attackRange = Math.max(20, u.range||25);
        const detectRange = attackRange + AGGRO_PAD;

        // Maintain or acquire a unit target
        if(u.goalUnit && u.goalUnit.hp>0){
          // If target wandered too far, drop it
          const dx=u.goalUnit.x-u.x, dy=u.goalUnit.y-u.y;
          const d=Math.hypot(dx,dy);
          if(d > detectRange*DROP_MULT){
            u.goalUnit = null;
          }
        }
        if(!u.goalUnit){
          u.goalUnit = nearestEnemyUnit(u, detectRange) || null;
        }

        // If we have a unit target, prioritize fighting it
        if(u.goalUnit){
          const dx=u.goalUnit.x-u.x, dy=u.goalUnit.y-u.y;
          const d=Math.hypot(dx,dy);
          if(d <= attackRange){
            if(u.cooldown<=0 && u.dmg>0){
              u.goalUnit.hp -= u.dmg;
              u.cooldown = 30; // ~0.5s
              if(u.goalUnit.hp<=0){ u.goalUnit=null; }
            }
          }else{
            moveTowards(u, u.goalUnit.x, u.goalUnit.y);
          }
          if(u.cooldown>0) u.cooldown--;
          return; // skip tower logic while engaged with a unit
        }

        // === ORIGINAL PATHING / TOWER TARGETING ===
        if(u.pathStage==='toBridge'){
          if(moveTowards(u, u.targetX, u.targetY)){
            u.pathStage='crossing';
            u.targetY = (u.side==='blue') ? (RIVER_Y - 8) : (RIVER_Y + RIVER_H + 8);
          }
          if(u.cooldown>0) u.cooldown--;
          return;
        }
        if(u.pathStage==='crossing'){
          if(moveTowards(u, u.targetX, u.targetY)){
            u.pathStage='toTarget';
          }
          if(u.cooldown>0) u.cooldown--;
          return;
        }

        // Choose/refresh tower goal
        if(!u.goal || u.goal.hp<=0){
          u.goal = nearestEnemyTower(u);
        }
        if(!u.goal){ if(u.cooldown>0) u.cooldown--; return; }

        const dx=u.goal.x - u.x, dy=u.goal.y - u.y;
        const dist = Math.hypot(dx,dy);

        if(dist <= attackRange){
          if(u.cooldown<=0 && u.dmg>0){
            u.goal.hp -= u.dmg;
            u.cooldown = 30; // ~0.5s
          }
        } else {
          moveTowards(u, u.goal.x, u.goal.y);
        }

        if(u.cooldown>0) u.cooldown--;
      });

      // Clean up dead dudes
      units = units.filter(u=>u.hp>0);
    }

    /* Tower AI */
    function updateTowersAI(){
      towers.forEach(t=>{
        if(t.hp<=0) return;
        t.cd = Math.max(0, (t.cd||0)-1);
        const range = t.range || (t.king?250:200);
        if(t.cd>0) return;

        let best=null, bestD2=Infinity;
        for(const u of units){
          if(u.side===t.side) continue;
          const dx=u.x - t.x, dy=u.y - t.y;
          const d2=dx*dx+dy*dy;
          if(d2 < range*range && d2 < bestD2){ best=u; bestD2=d2; }
        }
        if(best){
          const speed=7;
          const dx=best.x - t.x, dy=best.y - t.y;
          const mag=Math.max(0.001, Math.hypot(dx,dy));
          const vx=speed*dx/mag, vy=speed*dy/mag;
          projectiles.push({x:t.x, y:t.y, vx, vy, dmg:(t.dmg|| (t.king?35:22)), side:t.side});
          t.cd = t.cdMax || 60;
        }
      });
    }
    function updateProjectiles(){
      const radius=5;
      projectiles.forEach(p=>{
        p.x += p.vx; p.y += p.vy;
        for(const u of units){
          if(u.side===p.side) continue;
          const dx=u.x-p.x, dy=u.y-p.y;
          if(dx*dx+dy*dy <= (radius+12)*(radius+12)){
            u.hp -= p.dmg;
            p.dead=true;
          }
        }
        if(p.x<-20||p.x>canvas.width+20||p.y<-20||p.y>canvas.height+20) p.dead=true;
      });
      projectiles = projectiles.filter(p=>!p.dead);
    }

    function endGame(winnerColor){
      if(gameOver) return; gameOver=true;
      roomRef.child("state").set("ended");
      roomRef.child("winner").set(winnerColor);
      const iWon = (winnerColor==="Blue" && mySide==="blue") || (winnerColor==="Red" && mySide==="red");
      if(iWon){
        playerRef.child("coins").transaction(c=>(c||0)+100);
        playerRef.child("trophies").transaction(t=>(t||0)+5);
      }
      document.getElementById("resultText").innerText = iWon ? "🏆 Victory!" : "❌ Defeat";
      document.getElementById("rewardText").innerText = iWon ? "+100 Coins, +5 Trophies" : "Better luck next time!";
      document.getElementById("resultScreen").style.display="block";
    }

    function leaveRoomAndMaybeDelete(){
      if(!roomRef || !roomId || !roomCleanupArmed) return;
      const myPlayerNode = roomRef.child("players/"+playerId);
      myPlayerNode.update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});
      roomRef.child("players").once("value").then(s=>{
        let any=false; s.forEach(p=>{ if(p.val() && p.val().connected) any=true; });
        if(!any){ roomRef.remove(); }
      });
    }

    window.addEventListener("beforeunload", ()=>{
      playerRef.update({online:false, disconnected:true});
      leaveRoomAndMaybeDelete();
    });

    /* Host/non-host wiring */
    function attachHostListeners(){
      actionsRef.on("child_added", snap=>{
        const key=snap.key;
        if(pendingActionKeys.has(key)) return;
        pendingActionKeys.add(key);
        const a=snap.val();
        const side = (a.player===playerId) ? mySide : (mySide==="blue"?"red":"blue");
        spawnUnit(a.card, side, a.x, a.y);
      });
    }
    function attachClientStateListener(){
      stateRef.on("value", snap=>{
        const st=snap.val();
        if(!st) return;
        towers = (st.towers||[]).map(t=>({...t}));
        units  = (st.units ||[]).map(u=>({...u}));
      });
    }

    /* Names from room */
    async function loadRoomNames(){
      const playersSnap = await roomRef.child("players").once("value");
      let blueId=null, redId=null;
      playersSnap.forEach(ch=>{
        const v=ch.val(); if(!v) return;
        if(v.side==="blue") blueId=ch.key;
        if(v.side==="red")  redId=ch.key;
      });
      const [bNameSnap, rNameSnap] = await Promise.all([
        db.ref("players/"+blueId+"/name").once("value"),
        db.ref("players/"+redId+"/name").once("value")
      ]);
      nameBlue = bNameSnap.val() || "Blue";
      nameRed  = rNameSnap.val() || "Red";
    }

    /* Room auto-cleanup helpers */
    let inactiveCleanupTimer=null, endedCleanupTimer=null;
    function setupRoomAutoCleanup(){
      roomRef.child("state").on("value", s=>{
        if(s.val()==="ended"){
          if(endedCleanupTimer) clearTimeout(endedCleanupTimer);
          endedCleanupTimer = setTimeout(()=>{ roomRef.remove(); }, 15000);
        }
      });
      roomPlayersRef.on("value", s=>{
        let anyConnected=false;
        s.forEach(p=>{ const v=p.val(); if(v && v.connected) anyConnected=true; });
        if(!anyConnected){
          if(inactiveCleanupTimer) clearTimeout(inactiveCleanupTimer);
          inactiveCleanupTimer = setTimeout(()=>{ roomRef.remove(); }, 8000);
        }else{
          if(inactiveCleanupTimer){ clearTimeout(inactiveCleanupTimer); inactiveCleanupTimer=null; }
        }
      });
    }

    /* Main draw loop */
    function drawLoop(ts){
      drawArena();

      towers.forEach(t=> drawTower(t));
      const kBlue = towers.find(t=>t.side==="blue" && t.king);
      const kRed  = towers.find(t=>t.side==="red"  && t.king);
      if(kBlue) drawTowerName(kBlue, nameBlue);
      if(kRed)  drawTowerName(kRed,  nameRed);

      if(isHost && !gameOver){
        updateTowersAI();
        updateUnits();
        updateProjectiles();

        for(const t of towers){
          if(t.hp<=0 && t.king){
            const winner = (t.side==="blue") ? "Red" : "Blue";
            endGame(winner);
            break;
          }
        }

        if(ts - lastPublishTime >= PUBLISH_MS){
          lastPublishTime = ts;
          stateRef.set({
            towers: towers.map(t=>({x:t.x,y:t.y,hp:t.hp,side:t.side,king:!!t.king})),
            units:  units.map(u=>({x:u.x,y:u.y,hp:u.hp,maxHp:u.maxHp,side:u.side,name:u.name}))
          });
        }
      }

      projectiles.forEach(p=>{ ctx.fillStyle="#ffd86b"; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); });
      units.forEach(drawUnit);

      if(placementCircle && selectedCard){
        ctx.beginPath(); ctx.arc(placementCircle.x, placementCircle.y, 24, 0, Math.PI*2);
        ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.stroke();
      }

      if(!gameOver) requestAnimationFrame(drawLoop);
    }

    function startBattle(){
      searching=false; db.ref("queue/"+playerId).remove();
      if(pairInterval){ clearInterval(pairInterval); pairInterval=null; }

      document.getElementById("menuScreen").style.display="none";
      document.getElementById("battleScreen").style.display="block";
      document.getElementById("cardBar").style.display="flex";
      document.getElementById("elixirBar").style.display="flex";
      document.getElementById("statusText").innerText="In Battle (waiting for opponent…)";

      roomRef = db.ref("rooms/"+roomId);
      actionsRef = roomRef.child("actions");
      stateRef   = roomRef.child("authoritativeState");
      roomPlayersRef = roomRef.child("players");

      roomRef.child("host").transaction(v => v || playerId);

      roomRef.child("host").on("value", snap=>{
        hostId = snap.val();
        isHost = (hostId === playerId);
        if(isHost){
          if(stateRef) stateRef.off();
          attachHostListeners();
        }else{
          if(actionsRef) actionsRef.off();
          attachClientStateListener();
        }
      });

      roomRef.child("players/"+playerId).update({connected:true, side:mySide, name:playerName});
      roomRef.child("players/"+playerId).onDisconnect().update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});

      roomPlayersRef.once("value").then(s=>{
        let connected=0;
        s.forEach(p=>{ if(p.val() && p.val().connected) connected++; });
        battleReady = (connected>=2);
        document.getElementById("statusText").innerText = battleReady ? "In Battle" : "In Battle (waiting for opponent…)";
      });

      roomPlayersRef.on("value", s=>{
        let connected=0, hostConnected=false;
        s.forEach(p=>{
          const v=p.val(); if(!v) return;
          if(v.connected) connected++;
          if(p.key===hostId) hostConnected=!!v.connected;
        });
        battleReady = (connected>=2);
        document.getElementById("statusText").innerText = battleReady ? "In Battle" : "In Battle (waiting for opponent…)";
        if(!hostConnected && battleReady && hostId!==playerId){
          roomRef.child("host").transaction(v => v || playerId);
        }
      });

      loadRoomNames();

      elixir=5; lastElixirTime=Date.now(); initElixirBar();

      towers=[
        // Blue
        {x:200,y:560,hp:600,side:"blue",king:false, range:200, dmg:22, cdMax:60},
        {x:600,y:560,hp:600,side:"blue",king:false, range:200, dmg:22, cdMax:60},
        {x:400,y:640,hp:1000,side:"blue",king:true,  range:250, dmg:35, cdMax:60},
        // Red
        {x:200,y:140,hp:600,side:"red",king:false, range:200, dmg:22, cdMax:60},
        {x:600,y:140,hp:600,side:"red",king:false, range:200, dmg:22, cdMax:60},
        {x:400,y:60, hp:1000,side:"red",king:true,  range:250, dmg:35, cdMax:60}
      ];
      units=[]; projectiles=[]; gameOver=false; selectedCard=null; placementCircle=null; battleReady=false;
      pendingActionKeys.clear();

      playerRef.child("ownedCards").once("value").then(s=>{ renderHand(s.val()||{}); });
      playerRef.child("ownedCards").on("value", s=>{
        if(document.getElementById("battleScreen").style.display==="block"){
          renderHand(s.val()||{});
        }
      });

      setupRoomAutoCleanup();

      roomRef.child("winner").on("value", snap=>{
        const w=snap.val(); if(!w || gameOver) return;
        const iWon = (w==="Blue" && mySide==="blue") || (w==="Red" && mySide==="red");
        gameOver=true;
        document.getElementById("resultText").innerText = iWon ? "🏆 Victory!" : "❌ Defeat";
        document.getElementById("rewardText").innerText = iWon ? "+100 Coins, +5 Trophies" : "Better luck next time!";
        document.getElementById("resultScreen").style.display="block";
      });

      requestAnimationFrame(drawLoop);
    }

    function returnToMenu(){
      document.getElementById("resultScreen").style.display="none";
      document.getElementById("battleScreen").style.display="none";
      document.getElementById("menuScreen").style.display="block";
      document.getElementById("cardBar").style.display="none";
      document.getElementById("elixirBar").style.display="none";
      document.getElementById("statusText").innerText="Idle";

      if(actionsRef) actionsRef.off();
      if(stateRef)   stateRef.off();
      if(roomPlayersRef) roomPlayersRef.off();
      if(roomRef) roomRef.child("host").off();

      leaveRoomAndMaybeDelete();

      placementCircle=null; selectedCard=null; gameOver=false;
      roomId=null; mySide=null; searching=false; battleReady=false;
      queueAdded=false; isHost=false; hostId=null;

      playerRef.child("ownedCards").off();
    }

    /************ Leaderboard ************/
    function renderLeaderboard(rows){
      const container = document.getElementById('leaderboardRows');
      if(!container) return;
      container.innerHTML = '';
      rows.forEach((r, idx)=>{
        const div = document.createElement('div');
        div.className = 'lb-row';
        div.innerHTML = `
          <div class="lb-rank">${idx+1}</div>
          <div class="lb-name">${r.name || 'Anon'}</div>
          <div class="lb-trophies">🏆 ${r.trophies || 0}</div>
        `;
        container.appendChild(div);
      });
    }
    function subscribeLeaderboard(){
      db.ref('players').orderByChild('trophies').limitToLast(20).on('value', snap=>{
        const arr=[];
        snap.forEach(ch=>{
          const v = ch.val() || {};
          arr.push({ name: v.name || 'Anon', trophies: v.trophies || 0 });
        });
        arr.sort((a,b)=> b.trophies - a.trophies);
        renderLeaderboard(arr);
      });
    }
    subscribeLeaderboard();
  </script>

  <!-- CHANGELOG SCRIPT -->
  <script>
    (function(){
      function showChangelog(){
        var ov=document.getElementById('changelogOverlay');
        if(ov){ ov.style.display='flex'; }
      }
      function hideChangelog(){
        var ov=document.getElementById('changelogOverlay');
        if(ov){ ov.style.display='none'; }
      }
      document.addEventListener('DOMContentLoaded', function(){
        var btn=document.getElementById('changelogClose');
        var ov=document.getElementById('changelogOverlay');
        if(btn){ btn.addEventListener('click', hideChangelog); }
        if(ov){ ov.addEventListener('click', function(e){ if(e.target===ov) hideChangelog(); }); }
        showChangelog();
      });
    })();
  </script>

  <!-- OPTIONAL: randomize dancer delays (menu only) -->
  <script>
    (function(){
      const dancers = document.querySelectorAll('#dancerStage .dancer');
      if(!dancers.length) return;
      dancers.forEach((d,i)=>{
        const jitter = (Math.random()*0.25).toFixed(2);
        d.style.setProperty('--delay', (i*0.12 + parseFloat(jitter)) + 's');
      });
    })();
  </script>

  <!-- STARTING SPLASH logic + BGM start -->
  <script>
    (function(){
      const overlay = document.getElementById('startOverlay');
      const bgm = document.getElementById('bgm');

      function tryPlayBgm(){
        if(!bgm) return;
        bgm.play().catch(function(){
          // If still blocked, play on next user interaction
          const kick = function(){
            bgm.play().catch(()=>{}); // best effort
            document.removeEventListener('click', kick);
            document.removeEventListener('keydown', kick);
            document.removeEventListener('touchstart', kick);
          };
          document.addEventListener('click', kick, {once:true});
          document.addEventListener('keydown', kick, {once:true});
          document.addEventListener('touchstart', kick, {once:true});
        });
      }

      if(overlay){
        const hide = function(e){
          if(e){ e.preventDefault(); e.stopPropagation(); }
          overlay.style.transition = 'opacity 300ms ease';
          overlay.style.opacity = '0';
          setTimeout(()=>{ overlay.style.display='none'; }, 320);
          overlay.removeEventListener('click', hide);
          tryPlayBgm(); // start music after user gesture
        };
        overlay.addEventListener('click', hide);
      }
    })();
  </script>
</body>
</html>
