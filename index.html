<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flash Royale</title>
  <style>
    :root{
      --hud-bg: rgba(10,15,30,0.70);
      --hud-border:#1e3d59;
    }
    body{ margin:0; font-family:Arial, sans-serif; color:#fff; user-select:none; overflow:hidden; background:#0b0f1c; }

    /* Top HUD */
    .top-bar{
      display:flex; justify-content:space-between; align-items:center;
      padding:10px 20px; background:var(--hud-bg); border-bottom:3px solid var(--hud-border);
      font-size:14px; position:relative; z-index:3;
    }
    .currency{display:flex; gap:15px;}
    .currency div{background:#2d3e50; padding:5px 12px; border-radius:8px; display:flex; align-items:center; gap:6px;}
    #onlineCount{ margin-left:12px; font-weight:bold; }

    /* Screens */
    .screen{ display:none; height:calc(100vh - 56px); position:relative; }
    #menuScreen{ display:block; text-align:center; padding-bottom:120px; overflow:auto; }
    #battleScreen{ display:none; text-align:center; position:relative; }

    .battle-btn{
      background:#ffcc00; padding:20px 60px; border-radius:20px; font-size:32px; color:#000; cursor:pointer; margin-top:20px;
      border:3px solid #fff; box-shadow:0 0 25px rgba(255,255,0,0.9);
    }
    .cancel-btn{
      background:#ff4444; padding:15px 40px; border-radius:15px; font-size:24px; color:#fff; cursor:pointer; margin-top:20px;
      border:3px solid #fff; box-shadow:0 0 20px rgba(255,0,0,0.7); display:none;
    }

    .deck,.shop{
      display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin:20px auto; max-width:540px; position:relative; z-index:2;
    }
    .card{
      position:relative; border-radius:12px; overflow:hidden; text-align:center; font-size:12px; cursor:pointer;
      background:linear-gradient(to bottom, #2f3345, #151826); border:3px solid #889; box-shadow:0 3px 8px rgba(0,0,0,0.6); padding:8px;
    }
    .card img{ width:70%; margin:5px auto; display:block; }
    .card.selected{ border:3px solid cyan; box-shadow:0 0 15px cyan; }
    .card.cooldown{ opacity:0.45; pointer-events:none; filter:grayscale(0.5); }
    .elixir-cost{
      position:absolute; top:5px; left:5px; background:#9c27b0; border-radius:50%; width:28px; height:28px; display:flex; align-items:center; justify-content:center;
      font-size:14px; font-weight:bold; border:2px solid #fff;
    }
    .price-tag{ position:absolute; bottom:6px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.6); padding:2px 6px; border-radius:6px; font-size:12px; }
    .shop .buy-btn{ margin-top:6px; padding:6px 10px; border-radius:8px; border:2px solid #fff; background:#28a745; color:#fff; cursor:pointer; }
    .shop .owned{ margin-top:6px; padding:6px 10px; border-radius:8px; border:2px solid #888; background:#444; color:#aaa; }

    /* Procedural menu background (SVG) */
    #menuBg{ position:fixed; inset:0; z-index:0; pointer-events:none; }

    /* Arena canvas */
    #battleCanvas{
      position:relative; background:transparent; border:3px solid #fff; margin:20px auto 0; display:block; z-index:1;
    }

    /* Battle UI at bottom */
    #cardBar{
      position:fixed; bottom:100px; left:50%; transform:translateX(-50%);
      display:none; gap:10px; z-index:5;
    }
    #elixirBar{
      position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
      width:500px; height:24px; border:2px solid #fff; border-radius:10px; background:#222;
      display:none; justify-content:space-between; padding:2px; z-index:5;
    }
    .elixir-segment{ flex:1; margin:0 1px; background:#444; border-radius:4px; }
    .elixir-filled{ background:purple; }

    /* Result overlay */
    #resultScreen{
      display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8);
      color:#fff; text-align:center; font-size:32px; padding-top:200px; z-index:10;
    }
    #resultScreen button{
      margin-top:30px; padding:15px 40px; font-size:20px; border:none; border-radius:12px; cursor:pointer; background:gold; color:#000;
    }
  </style>

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
</head>
<body>
  <!-- Top HUD -->
  <div class="top-bar">
    <div class="currency">
      <div><img src="https://img.icons8.com/emoji/48/000000/coin-emoji.png" width="18" height="18"/> <span id="coinCount">0</span></div>
    </div>
    <div>
      <span id="statusText">Idle</span>
      <span id="onlineCount">Online: 0</span>
    </div>
  </div>

  <!-- MENU BACKGROUND (BUILT-IN) -->
  <svg id="menuBg" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice">
    <defs>
      <linearGradient id="sky" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#0b1228"/>
        <stop offset="60%" stop-color="#0b0f1c"/>
        <stop offset="100%" stop-color="#09101e"/>
      </linearGradient>
      <linearGradient id="mist" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#1c2444" stop-opacity="0.0"/>
        <stop offset="100%" stop-color="#1c2444" stop-opacity="0.35"/>
      </linearGradient>
      <linearGradient id="ground" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#0d1a2b"/>
        <stop offset="100%" stop-color="#0a1524"/>
      </linearGradient>
    </defs>
    <rect width="1920" height="1080" fill="url(#sky)"/>
    <path d="M0,720 C300,640 500,700 800,660 C1150,610 1450,690 1920,620 L1920,1080 L0,1080 Z" fill="#0c162e"/>
    <path d="M0,760 C350,700 550,760 850,740 C1200,710 1500,760 1920,700 L1920,1080 L0,1080 Z" fill="#0e1a35"/>
    <rect y="650" width="1920" height="430" fill="url(#mist)"/>
    <g transform="translate(960,520) scale(1.0)" fill="#1a2748" opacity="0.9">
      <rect x="-260" y="-60" width="520" height="200"/>
      <rect x="-330" y="-150" width="70" height="290"/><rect x="-330" y="-190" width="70" height="40"/>
      <rect x="260" y="-150" width="70" height="290"/><rect x="260" y="-190" width="70" height="40"/>
      <rect x="-90" y="-220" width="180" height="360"/><polygon points="-90,-220 0,-320 90,-220"/>
      <g>
        <rect x="-260" y="-60" width="30" height="30"/><rect x="-210" y="-60" width="30" height="30"/>
        <rect x="-160" y="-60" width="30" height="30"/><rect x="-110" y="-60" width="30" height="30"/>
        <rect x="-60" y="-60" width="30" height="30"/><rect x="-10" y="-60" width="30" height="30"/>
        <rect x="40" y="-60" width="30" height="30"/><rect x="90" y="-60" width="30" height="30"/>
        <rect x="140" y="-60" width="30" height="30"/><rect x="190" y="-60" width="30" height="30"/>
        <rect x="240" y="-60" width="30" height="30"/>
      </g>
    </g>
    <rect y="800" width="1920" height="280" fill="url(#ground)"/>
  </svg>

  <!-- MENU -->
  <div id="menuScreen" class="screen">
    <h2>üèÜ Flash Royale</h2>
    <p>Name: <b id="playerNameLabel"></b></p>
    <p>Your trophies: <b id="trophies">0</b></p>

    <button id="battleBtn" class="battle-btn" onclick="findMatch()">BATTLE</button>
    <button id="cancelBtn" class="cancel-btn" onclick="cancelSearch()">Cancel</button>

    <h2>Your Deck</h2>
    <div class="deck" id="deck"></div>

    <h2>Shop</h2>
    <div class="shop" id="shop"></div>
  </div>

  <!-- BATTLE -->
  <div id="battleScreen" class="screen">
    <canvas id="battleCanvas" width="800" height="700"></canvas>
  </div>

  <!-- Battle UI -->
  <div id="cardBar"></div>
  <div id="elixirBar"></div>

  <!-- Result -->
  <div id="resultScreen">
    <h1 id="resultText"></h1>
    <p id="rewardText"></p>
    <button onclick="returnToMenu()">OK</button>
  </div>

  <script>
    /************ Firebase Init ************/
    const firebaseConfig = {
      apiKey: "AIzaSyA3FUH9RZiQ9IRChNpGqNrgjt2r5AA5RF8",
      authDomain: "flash-royale-a92c0.firebaseapp.com",
      databaseURL: "https://flash-royale-a92c0-default-rtdb.firebaseio.com",
      projectId: "flash-royale-a92c0",
      storageBucket: "flash-royale-a92c0.appspot.com",
      messagingSenderId: "703977930640",
      appId: "1:703977930640:web:a4f70deb5bbe508aec7d15",
      measurementId: "G-61B7P6WEL0"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    /************ Player & Presence ************/
    const sanitizeName = s => (s||"").replace(/[^a-zA-Z0-9]/g,"").substring(0,6) || "Anon";

    let playerId = localStorage.getItem("playerId");
    if(!playerId){ playerId="player-"+Math.floor(Math.random()*10000); localStorage.setItem("playerId",playerId); }

    let playerName = localStorage.getItem("playerName");
    if(!playerName){ playerName = sanitizeName(prompt("Enter your player name (max 6 chars):","")); localStorage.setItem("playerName",playerName); }
    document.getElementById("playerNameLabel").innerText = playerName;

    const playerRef = db.ref("players/"+playerId);

    // Initialize if missing; start with 400 coins (legacy users without coins also set to 400 once)
    playerRef.once("value").then(snap=>{
      if(!snap.exists()){
        playerRef.set({
          name: playerName, online: true, disconnected: false,
          coins: 400, trophies: 0,
          ownedCards: { "Knight": true, "Archer": true, "Golem": true, "Dragon": true }
        });
      } else {
        const p = snap.val()||{};
        const updates = { name:playerName, online:true, disconnected:false };
        if(p.coins===undefined || p.coins===null) updates.coins = 400;
        playerRef.update(updates);
      }
    });

    // HUD sync
    playerRef.on("value", s=>{
      const p = s.val()||{};
      document.getElementById("coinCount").innerText = p.coins||0;
      document.getElementById("trophies").innerText = p.trophies||0;
    });

    // Online count
    db.ref("players").on("value", snap=>{
      let online=0; snap.forEach(c=>{ if(c.val() && c.val().online) online++; });
      document.getElementById("onlineCount").innerText = "Online: "+online;
    });

    // Presence flags
    playerRef.onDisconnect().update({ online:false, disconnected:true });

    /************ Cards (24 total) ************/
    const allCards = [
      {name:"Knight",hp:200,maxHp:200,dmg:20,range:20,cost:3,speed:2,img:"https://img.icons8.com/color/96/knight.png", price:0},
      {name:"Archer",hp:120,maxHp:120,dmg:15,range:120,cost:3,speed:2,img:"https://img.icons8.com/color/96/bow.png", price:0},
      {name:"Golem",hp:400,maxHp:400,dmg:30,range:20,cost:6,speed:1,img:"https://img.icons8.com/color/96/rock.png", price:0},
      {name:"Dragon",hp:150,maxHp:150,dmg:40,range:100,cost:5,speed:3,img:"https://img.icons8.com/color/96/dragon.png", price:0},

      {name:"Wizard",hp:160,maxHp:160,dmg:35,range:150,cost:5,speed:2,img:"https://img.icons8.com/color/96/wizard.png", price:500},
      {name:"Goblin",hp:90,maxHp:90,dmg:12,range:15,cost:2,speed:4,img:"https://img.icons8.com/color/96/goblin.png", price:200},
      {name:"Barbarian",hp:220,maxHp:220,dmg:25,range:20,cost:4,speed:2,img:"https://img.icons8.com/color/96/barbarian.png", price:400},
      {name:"Ice Spirit",hp:80,maxHp:80,dmg:10,range:10,cost:1,speed:5,img:"https://img.icons8.com/color/96/snowflake.png", price:150},
      {name:"Giant",hp:600,maxHp:600,dmg:45,range:25,cost:7,speed:1,img:"https://img.icons8.com/color/96/giant.png", price:700},
      {name:"Musketeer",hp:140,maxHp:140,dmg:30,range:200,cost:4,speed:2,img:"https://img.icons8.com/color/96/musket.png", price:450},
      {name:"Prince",hp:280,maxHp:280,dmg:50,range:20,cost:5,speed:3,img:"https://img.icons8.com/color/96/prince.png", price:600},
      {name:"Dark Knight",hp:260,maxHp:260,dmg:35,range:30,cost:5,speed:3,img:"https://img.icons8.com/color/96/darth-vader.png", price:600},
      {name:"Healer",hp:150,maxHp:150,dmg:0,range:150,cost:4,speed:2,img:"https://img.icons8.com/color/96/angel.png", price:400},
      {name:"Bomber",hp:110,maxHp:110,dmg:45,range:25,cost:3,speed:2,img:"https://img.icons8.com/color/96/bomb.png", price:300},
      {name:"Skeleton Army",hp:50,maxHp:50,dmg:10,range:10,cost:3,speed:4,img:"https://img.icons8.com/color/96/skeleton.png", price:250},
      {name:"Valkyrie",hp:260,maxHp:260,dmg:40,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/valkyrie.png", price:450},
      {name:"Hog Rider",hp:280,maxHp:280,dmg:55,range:20,cost:4,speed:4,img:"https://img.icons8.com/color/96/boar.png", price:500},
      {name:"Electro Spirit",hp:100,maxHp:100,dmg:20,range:60,cost:2,speed:4,img:"https://img.icons8.com/color/96/lightning-bolt.png", price:250},
      {name:"Baby Dragon",hp:180,maxHp:180,dmg:35,range:80,cost:4,speed:3,img:"https://img.icons8.com/color/96/baby-dragon.png", price:500},
      {name:"Pekka",hp:700,maxHp:700,dmg:80,range:25,cost:8,speed:1,img:"https://img.icons8.com/color/96/robot.png", price:800},
      {name:"Bandit",hp:200,maxHp:200,dmg:40,range:20,cost:4,speed:5,img:"https://img.icons8.com/color/96/ninja.png", price:500},
      {name:"Witch",hp:160,maxHp:160,dmg:25,range:180,cost:5,speed:2,img:"https://img.icons8.com/color/96/witch.png", price:500},
      {name:"Bowler",hp:300,maxHp:300,dmg:35,range:150,cost:6,speed:2,img:"https://img.icons8.com/color/96/bowling-ball.png", price:600},
      {name:"Hunter",hp:200,maxHp:200,dmg:50,range:100,cost:4,speed:3,img:"https://img.icons8.com/color/96/shotgun.png", price:500},
      {name:"Mega Minion",hp:140,maxHp:140,dmg:30,range:50,cost:3,speed:3,img:"https://img.icons8.com/color/96/minion.png", price:350}
    ];

    /* Deck + Shop render */
    function renderDeck(owned){
      const deckEl = document.getElementById("deck");
      deckEl.innerHTML="";
      allCards.forEach(c=>{
        if(!owned || owned[c.name]){
          const d=document.createElement("div");
          d.className="card";
          d.innerHTML=`<div class="elixir-cost">${c.cost}</div><img src="${c.img}"><b>${c.name}</b>`;
          deckEl.appendChild(d);
        }
      });
    }
    function renderShop(owned, coins){
      const shop = document.getElementById("shop"); shop.innerHTML="";
      allCards.forEach(c=>{
        if(c.price<=0) return;
        const ownedFlag = !!owned[c.name];
        const el = document.createElement("div");
        el.className="card";
        el.innerHTML = `
          <div class="elixir-cost">${c.cost}</div>
          <img src="${c.img}">
          <b>${c.name}</b>
          <div class="price-tag">${c.price} ü™ô</div>
          <div class="${ownedFlag?'owned':'buy-btn'}">${ownedFlag?'Owned':'Buy'}</div>
        `;
        if(!ownedFlag){
          el.querySelector('.buy-btn').onclick = async ()=>{
            const snap = await playerRef.get(); const p = snap.val()||{};
            const have = p.coins||0;
            if(have < c.price){ alert("Not enough coins!"); return; }
            await playerRef.child("coins").transaction(v => (v||0)-c.price);
            await playerRef.child("ownedCards/"+c.name).set(true);
          };
        }
        shop.appendChild(el);
      });
    }
    playerRef.on("value", s=>{
      const p=s.val()||{}; const owned=p.ownedCards||{};
      renderDeck(owned); renderShop(owned, p.coins||0);
    });

    /************ Elixir ************/
    let elixir=0, maxElixir=10, elixirRegenRate=2000, lastElixirTime=Date.now();
    function initElixirBar(){
      const bar=document.getElementById("elixirBar"); bar.innerHTML="";
      for(let i=0;i<maxElixir;i++){ const seg=document.createElement("div"); seg.className="elixir-segment"; seg.id="elixir-"+i; bar.appendChild(seg); }
    }
    function updateElixir(){
      const now=Date.now();
      if(now-lastElixirTime>=elixirRegenRate && elixir<maxElixir){ elixir++; lastElixirTime=now; }
      for(let i=0;i<maxElixir;i++){ const seg=document.getElementById("elixir-"+i); if(seg) seg.classList.toggle("elixir-filled", i<elixir); }
    }
    setInterval(updateElixir, 200);

    /************ Matchmaking (strict 1v1; multiple rooms supported) ************/
    let roomId=null, mySide=null, searching=false, battleReady=false;
    let actionsRef=null, roomPlayersRef=null, queueAdded=false;

    function findMatch(){
      document.getElementById("statusText").innerText="Searching...";
      document.getElementById("battleBtn").style.display="none";
      document.getElementById("cancelBtn").style.display="inline-block";
      searching=true;

      const myQueueRef = db.ref("queue/"+playerId);
      if(!queueAdded){
        myQueueRef.set({ name:playerName, ts:firebase.database.ServerValue.TIMESTAMP, searching:true });
        myQueueRef.onDisconnect().remove();
        queueAdded=true;
      }
      attemptPair();
      // Also listen if someone pairs us (we'll be inside a new room)
      db.ref("rooms").on("child_added", snap=>{
        if(!searching || roomId) return;
        const r=snap.val();
        if(r && r.players && r.players[playerId]){
          roomId=snap.key;
          mySide = r.players[playerId].side || "red";
          startBattle();
        }
      });
    }

    function attemptPair(){
      db.ref("queue").once("value").then(snap=>{
        if(!searching || roomId) return;
        const q = snap.val()||{};
        // choose oldest other player that isn't claimed
        let cand=null, bestTs=Infinity;
        Object.keys(q).forEach(k=>{
          if(k===playerId) return;
          const it=q[k]; if(!it || it.claimed) return;
          const ts = typeof it.ts==='number' ? it.ts : Date.now();
          if(ts<bestTs){ bestTs=ts; cand=k; }
        });
        if(!cand) return; // nobody else ‚Üí remain "Searching" until someone joins

        // atomic claim to prevent race
        db.ref("queue/"+cand+"/claimed").transaction(val=>{
          if(val) return; return playerId;
        }, async (err, committed, snap2)=>{
          if(err || !committed || snap2.val()!==playerId){ return; }
          // fetch opponent name for room labeling
          const oppNameSnap = await db.ref("players/"+cand+"/name").once("value");
          const oppName = oppNameSnap.val() || "Opponent";

          roomId = "room-"+Date.now()+"-"+Math.floor(Math.random()*1000);
          mySide = "blue";
          const roomData={
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            state:"active",
            players:{
              [playerId]:{connected:true,side:"blue",name:playerName},
              [cand]:{connected:true,side:"red",name:oppName}
            }
          };
          db.ref("rooms/"+roomId).set(roomData).then(()=>{
            db.ref("queue/"+cand).remove();
            db.ref("queue/"+playerId).remove();
            startBattle();
          });
        });
      });
    }

    function cancelSearch(){
      searching=false;
      db.ref("queue/"+playerId).remove();
      queueAdded=false;
      document.getElementById("statusText").innerText="Idle";
      document.getElementById("battleBtn").style.display="inline-block";
      document.getElementById("cancelBtn").style.display="none";
    }

    // Rejoin an active room if you refreshed
    function tryRejoinRoom(){
      db.ref("rooms").once("value").then(s=>{
        s.forEach(r=>{
          const val=r.val();
          if(val && val.state==="active" && val.players && val.players[playerId]){
            roomId=r.key; mySide=val.players[playerId].side||"red";
            startBattle();
          }
        });
      });
    }
    playerRef.once("value").then(s=>{
      const p=s.val()||{};
      if(p.disconnected){ tryRejoinRoom(); playerRef.update({disconnected:false, online:true}); }
    });

    /************ Battle ************/
    const canvas=document.getElementById("battleCanvas");
    const ctx=canvas.getContext("2d");
    const towerImg=new Image(); towerImg.src="mini-castle.png";

    // Arena geometry (used for drawing AND pathing)
    const RIVER_H = 40;
    const BRIDGE_W = 140;
    const RIVER_Y = canvas.height/2 - RIVER_H/2;
    const BRIDGE_CENTERS = [220, 580]; // x centers

    let towers=[], units=[], selectedCard=null;
    let placementCircle=null, lastMouse={x:canvas.width/2, y:canvas.height*0.75};
    const cardCooldowns={}; // name -> timestamp
    let projectiles=[]; // tower shots
    let gameOver=false;
    let nameBlue="Blue", nameRed="Red"; // populated from room

    // Hand (owned cards)
    function renderHand(owned){
      const bar=document.getElementById("cardBar"); bar.innerHTML="";
      allCards.forEach(card=>{
        if(!owned[card.name]) return;
        const d=document.createElement("div"); d.className="card";
        d.innerHTML=`<div class="elixir-cost">${card.cost}</div><img src="${card.img}"><b>${card.name}</b>`;
        const now=Date.now(); const cd=cardCooldowns[card.name]||0;
        if(cd>now) d.classList.add("cooldown");
        d.onclick=()=>{
          if((cardCooldowns[card.name]||0) > Date.now()) return;
          selectedCard=card;
          highlightSelected(d);
          let y=lastMouse.y;
          if(mySide==="blue" && y<canvas.height/2) y=canvas.height/2;
          if(mySide==="red"  && y>canvas.height/2) y=canvas.height/2;
          placementCircle={x:lastMouse.x, y};
        };
        bar.appendChild(d);
      });
    }
    function highlightSelected(el){
      document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
      el.classList.add("selected");
    }
    function refreshCooldownStyles(){
      const now=Date.now();
      document.querySelectorAll("#cardBar .card").forEach(el=>{
        const nameEl=el.querySelector("b"); if(!nameEl) return;
        const nm=nameEl.textContent;
        el.classList.toggle("cooldown", (cardCooldowns[nm]||0) > now);
      });
    }

    function clampToHalf(x,y){
      if(mySide==="blue" && y<canvas.height/2) y=canvas.height/2;
      if(mySide==="red"  && y>canvas.height/2) y=canvas.height/2;
      if(x<20) x=20; if(x>canvas.width-20) x=canvas.width-20;
      if(y<20) y=20; if(y>canvas.height-20) y=canvas.height-20;
      return {x,y};
    }
    canvas.addEventListener("mousemove", e=>{
      const r=canvas.getBoundingClientRect();
      lastMouse.x = e.clientX - r.left;
      lastMouse.y = e.clientY - r.top;
      if(!selectedCard){ placementCircle=null; return; }
      placementCircle = clampToHalf(lastMouse.x, lastMouse.y);
    });

    // Drop card (only when 2 players are connected)
    canvas.addEventListener("click", e=>{
      if(!battleReady) return;
      if(!selectedCard) return;
      const rect=canvas.getBoundingClientRect();
      let x=e.clientX-rect.left, y=e.clientY-rect.top;
      ({x,y}=clampToHalf(x,y));
      if(elixir < selectedCard.cost) return;

      elixir -= selectedCard.cost;
      cardCooldowns[selectedCard.name]=Date.now()+5000;
      refreshCooldownStyles();

      const action={ player:playerId, card:selectedCard, x, y, timestamp:Date.now() };
      db.ref("rooms/"+roomId+"/actions").push(action);

      selectedCard=null; placementCircle=null;
      document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
    });

    /* Arena draw with TWO BRIDGES and river */
    function drawArena(){
      // grass
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,"#0f2b1f"); g.addColorStop(0.5,"#123725"); g.addColorStop(1,"#0f2b1f");
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

      // river
      ctx.fillStyle="#243a5e";
      ctx.fillRect(0, RIVER_Y, canvas.width, RIVER_H);

      // two bridges
      const bridges=[ {x:BRIDGE_CENTERS[0]-BRIDGE_W/2, y:RIVER_Y-6}, {x:BRIDGE_CENTERS[1]-BRIDGE_W/2, y:RIVER_Y-6} ];
      ctx.fillStyle="#6e5537";
      bridges.forEach(b=>{
        ctx.fillRect(b.x, b.y, BRIDGE_W, RIVER_H+12);
        // planks
        ctx.fillStyle="#7a6040";
        for(let i=0;i<BRIDGE_W;i+=18){
          ctx.fillRect(b.x+i+2, b.y, 8, RIVER_H+12);
        }
        ctx.fillStyle="#6e5537";
      });

      // lane lines
      ctx.strokeStyle="rgba(255,255,255,0.15)"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0, canvas.height/3); ctx.lineTo(canvas.width, canvas.height/3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, canvas.height*2/3); ctx.lineTo(canvas.width, canvas.height*2/3); ctx.stroke();

      // halves tint
      ctx.fillStyle="rgba(0,0,255,0.05)"; ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
      ctx.fillStyle="rgba(255,0,0,0.05)"; ctx.fillRect(0, 0, canvas.width, canvas.height/2);
    }

    function drawTower(t){
      const size = t.king ? 60 : 50;
      if(towerImg.complete){ ctx.drawImage(towerImg, t.x-size/2, t.y-size/2, size, size); }
      else{ ctx.fillStyle=t.side==="blue"?"#5ec8ff":"#ff6b6b"; ctx.fillRect(t.x-size/2, t.y-size/2, size, size); }
      // HP bar
      const maxHp = t.king?1000:600;
      ctx.fillStyle="#900"; ctx.fillRect(t.x-28, t.y-(size/2)-10, 56, 6);
      ctx.fillStyle="#3f3"; ctx.fillRect(t.x-28, t.y-(size/2)-10, 56*(Math.max(0,t.hp)/maxHp), 6);
    }
    function drawTowerName(t, nm){
      if(!nm) return;
      ctx.font='16px Arial'; ctx.textAlign='center'; ctx.lineWidth=3; ctx.strokeStyle='black';
      const size = t.king ? 60 : 50;
      const y = t.side==='blue' ? (t.y + size/2 + 18) : (t.y - size/2 - 14);
      ctx.strokeText(nm, t.x, y);
      ctx.fillStyle='white'; ctx.fillText(nm, t.x, y);
    }

    function pickNearestBridgeX(x){
      const a=BRIDGE_CENTERS[0], b=BRIDGE_CENTERS[1];
      return (Math.abs(x-a) <= Math.abs(x-b)) ? a : b;
    }

    function spawnUnit(card, side, x, y){
      const slowFactor = 0.45; // MUCH slower, but animated
      const speed = Math.max(0.4, card.speed * slowFactor);

      const bridgeX = pickNearestBridgeX(x);
      const startTargetY = side==='blue' ? (RIVER_Y + RIVER_H + 8) : (RIVER_Y - 8);

      units.push({
        name:card.name, hp:card.hp, maxHp:card.maxHp, dmg:card.dmg, range:card.range,
        speed, side, x, y, cooldown:0, dir:(side==="blue" ? -1 : 1),
        pathStage:'toBridge', targetX: bridgeX, targetY: startTargetY
      });
    }

    function drawUnit(u){
      ctx.fillStyle = (u.side==="blue") ? "#8de1ff" : "#ff7f7f";
      ctx.beginPath(); ctx.arc(u.x, u.y, 14, 0, Math.PI*2); ctx.fill();
      // simple leg jiggle
      const step = Math.sin(Date.now()/120)*4;
      ctx.strokeStyle=(u.side==="blue")?"#c7f1ff":"#ffd1d1"; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(u.x-8, u.y+14); ctx.lineTo(u.x-8, u.y+20+step); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(u.x+8, u.y+14); ctx.lineTo(u.x+8, u.y+20-step); ctx.stroke();
      // hp bar
      ctx.fillStyle="#900"; ctx.fillRect(u.x-15, u.y-24, 30, 5);
      ctx.fillStyle="#3f3"; ctx.fillRect(u.x-15, u.y-24, 30*(u.hp/u.maxHp), 5);
    }

    function moveTowards(u, tx, ty){
      const dx=tx-u.x, dy=ty-u.y;
      const dist = Math.hypot(dx,dy);
      if(dist <= u.speed){ u.x=tx; u.y=ty; return true; }
      u.x += u.speed * dx/dist;
      u.y += u.speed * dy/dist;
      return false;
    }

    function updateUnits(){
      units.forEach(u=>{
        // Pathing: force bridge crossing
        if(u.pathStage==='toBridge'){
          if(moveTowards(u, u.targetX, u.targetY)){
            // next: crossing to the other side
            u.pathStage='crossing';
            u.targetX = u.targetX;
            u.targetY = (u.side==='blue') ? (RIVER_Y - 8) : (RIVER_Y + RIVER_H + 8);
          }
        } else if(u.pathStage==='crossing'){
          if(moveTowards(u, u.targetX, u.targetY)){
            u.pathStage='toTarget';
          }
        } else {
          // toTarget: proceed straight toward enemy territory
          u.y += u.dir * u.speed;
        }

        // cooldown tick
        if(u.cooldown>0) u.cooldown--;

        // attack towers on contact
        for(const t of towers){
          if(t.side===u.side || t.hp<=0) continue;
          const dx=Math.abs(u.x - t.x), dy=Math.abs(u.y - t.y);
          if(dx<30 && dy<30){
            if(u.cooldown<=0){
              t.hp -= u.dmg;
              u.cooldown = 30; // ~0.5s
            }
          }
        }
      });
      units = units.filter(u=>u.hp>0);
    }

    /* Tower AI (auto-shoot) */
    let projectiles=[]; // {x,y,vx,vy,dmg,side}
    function updateTowersAI(){
      towers.forEach(t=>{
        if(t.hp<=0) return;
        t.cd = Math.max(0, (t.cd||0)-1);
        const range = t.range || (t.king?250:200);
        if(t.cd>0) return;

        // find nearest enemy unit in range
        let best=null, bestD2=Infinity;
        for(const u of units){
          if(u.side===t.side) continue;
          const dx=u.x - t.x, dy=u.y - t.y;
          const d2=dx*dx+dy*dy;
          if(d2 < range*range && d2 < bestD2){ best=u; bestD2=d2; }
        }
        if(best){
          const speed=7;
          const dx=best.x - t.x, dy=best.y - t.y;
          const mag=Math.max(0.001, Math.hypot(dx,dy));
          const vx=speed*dx/mag, vy=speed*dy/mag;
          projectiles.push({x:t.x, y:t.y, vx, vy, dmg:(t.dmg|| (t.king?35:22)), side:t.side});
          t.cd = t.cdMax || 60; // ~1s at 60fps
        }
      });
    }
    function updateProjectiles(){
      const radius=5;
      projectiles.forEach(p=>{
        p.x += p.vx; p.y += p.vy;
        // hit unit?
        for(const u of units){
          if(u.side===p.side) continue;
          const dx=u.x-p.x, dy=u.y-p.y;
          if(dx*dx+dy*dy <= (radius+12)*(radius+12)){
            u.hp -= p.dmg;
            p.dead=true;
            break;
          }
        }
        // out of bounds
        if(p.x<-20||p.x>canvas.width+20||p.y<-20||p.y>canvas.height+20) p.dead=true;
      });
      projectiles = projectiles.filter(p=>!p.dead);
    }
    function drawProjectiles(){
      ctx.fillStyle="#ffd86b";
      projectiles.forEach(p=>{
        ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
      });
    }

    function endGame(winnerColor){
      if(gameOver) return; gameOver=true;
      db.ref("rooms/"+roomId+"/state").set("ended");
      db.ref("rooms/"+roomId+"/winner").set(winnerColor);
      const iWon = (winnerColor==="Blue" && mySide==="blue") || (winnerColor==="Red" && mySide==="red");
      if(iWon){
        playerRef.child("coins").transaction(c=>(c||0)+100);
        playerRef.child("trophies").transaction(t=>(t||0)+5);
      }
      document.getElementById("resultText").innerText = iWon ? "üèÜ Victory!" : "‚ùå Defeat";
      document.getElementById("rewardText").innerText = iWon ? "+100 Coins, +5 Trophies" : "Better luck next time!";
      document.getElementById("resultScreen").style.display="block";
    }

    function leaveRoomAndMaybeDelete(){
      if(!roomId) return;
      const myRef = db.ref("rooms/"+roomId+"/players/"+playerId);
      myRef.update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});
      db.ref("rooms/"+roomId+"/players").once("value").then(s=>{
        let any=false; s.forEach(p=>{ if(p.val() && p.val().connected) any=true; });
        if(!any){ db.ref("rooms/"+roomId).remove(); }
      });
    }

    window.addEventListener("beforeunload", ()=>{
      playerRef.update({online:false, disconnected:true});
      leaveRoomAndMaybeDelete();
    });

    /* Names from room */
    async function loadRoomNames(){
      const playersSnap = await db.ref("rooms/"+roomId+"/players").once("value");
      let blueId=null, redId=null;
      playersSnap.forEach(ch=>{
        const v=ch.val(); if(!v) return;
        if(v.side==="blue") blueId=ch.key;
        if(v.side==="red")  redId=ch.key;
      });
      const [bNameSnap, rNameSnap] = await Promise.all([
        db.ref("players/"+blueId+"/name").once("value"),
        db.ref("players/"+redId+"/name").once("value")
      ]);
      nameBlue = bNameSnap.val() || "Blue";
      nameRed  = rNameSnap.val() || "Red";
    }

    /* Main battle loop */
    function drawLoop(){
      // arena
      drawArena();

      // towers (draw + check king death)
      towers.forEach(t=>{
        drawTower(t);
      });

      // names on king castles
      const kBlue = towers.find(t=>t.side==="blue" && t.king);
      const kRed  = towers.find(t=>t.side==="red"  && t.king);
      if(kBlue) drawTowerName(kBlue, nameBlue);
      if(kRed)  drawTowerName(kRed,  nameRed);

      // win check after drawing (so names always visible)
      towers.forEach(t=>{
        if(!gameOver && t.hp<=0 && t.king){
          const winner = (t.side==="blue") ? "Red" : "Blue";
          endGame(winner);
        }
      });

      // AI + units + projectiles
      updateTowersAI();
      updateUnits();
      updateProjectiles();
      drawProjectiles();
      units.forEach(drawUnit);

      // placement circle
      if(placementCircle && selectedCard){
        ctx.beginPath(); ctx.arc(placementCircle.x, placementCircle.y, 24, 0, Math.PI*2);
        ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.stroke();
      }

      if(!gameOver) requestAnimationFrame(drawLoop);
    }

    function startBattle(){
      searching=false; db.ref("queue/"+playerId).remove();

      // show battle UI
      document.getElementById("menuScreen").style.display="none";
      document.getElementById("battleScreen").style.display="block";
      document.getElementById("cardBar").style.display="flex";
      document.getElementById("elixirBar").style.display="flex";
      document.getElementById("statusText").innerText="In Battle (waiting for opponent‚Ä¶)";

      // init elixir & bar
      elixir=5; lastElixirTime=Date.now(); initElixirBar();

      // towers (two princess + one big king per side)
      towers=[
        // Blue side (bottom)
        {x:200,y:560,hp:600,side:"blue",king:false, range:200, dmg:22, cdMax:60},
        {x:600,y:560,hp:600,side:"blue",king:false, range:200, dmg:22, cdMax:60},
        {x:400,y:640,hp:1000,side:"blue",king:true,  range:250, dmg:35, cdMax:60},
        // Red side (top)
        {x:200,y:140,hp:600,side:"red",king:false, range:200, dmg:22, cdMax:60},
        {x:600,y:140,hp:600,side:"red",king:false, range:200, dmg:22, cdMax:60},
        {x:400,y:60, hp:1000,side:"red",king:true,  range:250, dmg:35, cdMax:60}
      ];
      units=[]; projectiles=[]; gameOver=false; selectedCard=null; placementCircle=null; battleReady=false;

      // ensure our player row in room has our name (in case host didn't set it)
      db.ref("rooms/"+roomId+"/players/"+playerId).update({connected:true, side:mySide, name:playerName});
      db.ref("rooms/"+roomId+"/players/"+playerId).onDisconnect().update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});

      // wait for both players ‚Üí only then allow dropping units
      roomPlayersRef = db.ref("rooms/"+roomId+"/players");
      roomPlayersRef.on("value", s=>{
        let connected=0; s.forEach(p=>{ if(p.val() && p.val().connected) connected++; });
        battleReady = (connected>=2);
        document.getElementById("statusText").innerText = battleReady ? "In Battle" : "In Battle (waiting for opponent‚Ä¶)";
      });

      // load names for drawing near castles
      loadRoomNames();

      // load owned & render hand
      playerRef.child("ownedCards").once("value").then(s=>{
        renderHand(s.val()||{});
      });

      // actions listener (sync spawns)
      if(actionsRef) actionsRef.off();
      actionsRef = db.ref("rooms/"+roomId+"/actions");
      actionsRef.on("child_added", snap=>{
        const a=snap.val();
        const side = (a.player===playerId) ? mySide : (mySide==="blue"?"red":"blue");
        spawnUnit(a.card, side, a.x, a.y);
      });

      requestAnimationFrame(drawLoop);
    }

    function leaveRoomAndMaybeDelete(){
      if(!roomId) return;
      const myRef = db.ref("rooms/"+roomId+"/players/"+playerId);
      myRef.update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});
      db.ref("rooms/"+roomId+"/players").once("value").then(s=>{
        let any=false; s.forEach(p=>{ if(p.val() && p.val().connected) any=true; });
        if(!any){ db.ref("rooms/"+roomId).remove(); }
      });
    }

    function returnToMenu(){
      document.getElementById("resultScreen").style.display="none";
      document.getElementById("battleScreen").style.display="none";
      document.getElementById("menuScreen").style.display="block";
      document.getElementById("cardBar").style.display="none";
      document.getElementById("elixirBar").style.display="none";
      document.getElementById("statusText").innerText="Idle";

      if(actionsRef) actionsRef.off();
      if(roomPlayersRef) roomPlayersRef.off();

      leaveRoomAndMaybeDelete();

      placementCircle=null; selectedCard=null; gameOver=false;
      roomId=null; mySide=null; searching=false; battleReady=false;
      queueAdded=false;
    }
  </script>
</body>
</html>
