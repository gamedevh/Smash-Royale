# Write the fully merged HTML (with real per-card avatars/sprites) to a new file
html = r"""<!DOCTYPE html>
<html lang="en">
<head>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6444487225655573"
crossorigin="anonymous"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-61B7P6WEL0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-61B7P6WEL0');
</script>
<meta charset="UTF-8" />
<title>Flash Royale</title>
<style>
:root{
--hud-bg: rgba(10,15,30,0.70);
--hud-border:#1e3d59;
}
body{ margin:0; font-family:Arial, sans-serif; color:#fff; user-select:none; overflow:hidden; background:#0b0f1c; }

/* Top HUD */
.top-bar{
display:flex; justify-content:space-between; align-items:center;
padding:10px 20px; background:var(--hud-bg); border-bottom:3px solid var(--hud-border);
font-size:14px; position:relative; z-index:3;
}
.currency{display:flex; gap:15px;}
.currency div{background:#2d3e50; padding:5px 12px; border-radius:8px; display:flex; align-items:center; gap:6px;}
#onlineCount{ margin-left:12px; font-weight:bold; }

/* Screens */
.screen{ display:none; height:calc(100vh - 56px); position:relative; }
#menuScreen{ display:block; text-align:center; padding-bottom:120px; overflow:auto; }
#battleScreen{ display:none; text-align:center; position:relative; }

.battle-btn{
background:#ffcc00; padding:20px 60px; border-radius:20px; font-size:32px; color:#000; cursor:pointer; margin-top:20px;
border:3px solid #fff; box-shadow:0 0 25px rgba(255,255,0,0.9);
}
.cancel-btn{
background:#ff4444; padding:15px 40px; border-radius:15px; font-size:24px; color:#fff; cursor:pointer; margin-top:20px;
border:3px solid #fff; box-shadow:0 0 20px rgba(255,0,0,0.7); display:none;
}

.deck,.shop{
display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin:20px auto; max-width:540px; position:relative; z-index:2;
}
.card{
position:relative; border-radius:12px; overflow:hidden; text-align:center; font-size:12px; cursor:pointer;
background:linear-gradient(to bottom, #2f3345, #151826); border:3px solid #889; box-shadow:0 3px 8px rgba(0,0,0,0.6); padding:8px;
}
.card img{ width:70%; margin:5px auto; display:block; }
.card.selected{ border:3px solid cyan; box-shadow:0 0 15px cyan; }
.card.cooldown{ opacity:0.45; pointer-events:none; filter:grayscale(0.5); }
.elixir-cost{
position:absolute; top:5px; left:5px; background:#9c27b0; border-radius:50%; width:28px; height:28px; display:flex; align-items:center; justify-content:center;
font-size:14px; font-weight:bold; border:2px solid #fff;
}
.price-tag{ position:absolute; bottom:6px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.6); padding:2px 6px; border-radius:6px; font-size:12px; }
.shop .buy-btn{ margin-top:6px; padding:6px 10px; border-radius:8px; border:2px solid #fff; background:#28a745; color:#fff; cursor:pointer; }
.shop .buy-btn[disabled]{ opacity:.6; cursor:not-allowed; }
.shop .owned{ margin-top:6px; padding:6px 10px; border-radius:8px; border:2px solid #888; background:#444; color:#aaa; }

/* === Card Levels & Upgrade === */
.level-badge{
  position:absolute; top:5px; right:5px;
  background:#0ea5e9; border:2px solid #fff; border-radius:12px;
  padding:2px 6px; font-weight:700; font-size:12px;
}
.upgrade-btn{
  margin-top:8px; padding:6px 10px; border-radius:8px;
  border:2px solid #fff; background:#2563eb; color:#fff; cursor:pointer;
}
.upgrade-btn[disabled]{ opacity:.6; cursor:not-allowed; }

/* Procedural menu background (SVG) */
#menuBg{ position:fixed; inset:0; z-index:0; pointer-events:none; }

/* Arena canvas */
#battleCanvas{
position:relative; background:transparent; border:3px solid #fff; margin:20px auto 0; display:block; z-index:1;
}

/* Battle UI at bottom */
#cardBar{
position:fixed; bottom:100px; left:50%; transform:translateX(-50%);
display:none; gap:10px; z-index:5;
}
#elixirBar{
position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
width:500px; height:24px; border:2px solid #fff; border-radius:10px; background:#222;
display:none; justify-content:space-between; padding:2px; z-index:5;
}
.elixir-segment{ flex:1; margin:0 1px; background:#444; border-radius:4px; }
.elixir-filled{ background:purple; }

/* Result overlay */
#resultScreen{
display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8);
color:#fff; text-align:center; font-size:32px; padding-top:200px; z-index:10;
}
#resultScreen button{
margin-top:30px; padding:15px 40px; font-size:20px; border:none; border-radius:12px; cursor:pointer; background:gold; color:#000;
}

/* --- CHANGELOG MODAL --- */
#changelogOverlay{
position:fixed; inset:0; background:rgba(0,0,0,0.65);
display:none; align-items:center; justify-content:center; z-index:20;
}
#changelogModal{
width:520px; max-width:calc(100% - 40px);
background:#111828; color:#e5e7eb;
border:2px solid #3b82f6; border-radius:18px;
box-shadow:0 20px 40px rgba(0,0,0,0.45);
padding:20px 20px 14px; position:relative;
}
#changelogTitle{ margin:0 0 10px; font-size:20px; }
#changelogList{ margin:0 0 8px 18px; padding:0; }
#changelogList li{ margin:6px 0; }
#changelogClose{
position:absolute; top:8px; right:8px;
width:32px; height:32px; border-radius:50%;
border:2px solid #93c5fd; background:#1f2937; color:#e5e7eb;
font-size:18px; line-height:26px; cursor:pointer;
}
#changelogClose:hover{ background:#374151; }
#changelogHint{ opacity:0.7; font-size:12px; }

/* --- LEADERBOARD (RIGHT) --- */
.leaderboard{
position:fixed;
right:20px;
top:90px; bottom:20px;
width:360px;
overflow:auto;
text-align:left;
background:rgba(17,24,39,0.85);
border:2px solid #334155; border-radius:16px;
box-shadow: 0 8px 24px rgba(0,0,0,0.35);
z-index:2;
}
.leaderboard h3{
margin:0; padding:12px 16px; background:#0f172a; border-bottom:2px solid #334155; font-size:18px;
}
.lb-row{ display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-bottom:1px solid rgba(255,255,255,0.07); }
.lb-row:nth-child(odd){ background:rgba(255,255,255,0.02); }
.lb-rank{ width:36px; text-align:center; font-weight:bold; }
.lb-name{ flex:1; padding:0 8px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.lb-trophies{ min-width:90px; text-align:right; font-weight:bold; }

/* === Dancing avatars (menu only) === */
#dancerStage{
position: fixed;
left: 20px;
right: 400px;
bottom: 20px;
display: flex;
gap: 14px;
align-items: flex-end;
pointer-events: none;
z-index: 1;
}
.dancer{
position: relative;
width: 64px; height: 64px;
border-radius: 50%;
background: radial-gradient(60% 60% at 50% 35%, #374151 0%, #0f172a 70%);
box-shadow: 0 8px 18px rgba(0,0,0,0.35), inset 0 0 12px rgba(59,130,246,0.25);
display: flex; align-items: center; justify-content: center;
animation: bob 1.8s ease-in-out infinite;
animation-delay: var(--delay, 0s);
}
.dancer span{
font-size: 34px; line-height: 1;
filter: drop-shadow(0 2px 2px rgba(0,0,0,0.45));
animation: wiggle 1.4s ease-in-out infinite;
animation-delay: calc(var(--delay, 0s) * 1.15);
}
.dancer::after{
content: "";
position: absolute;
bottom: -6px; left: 50%; transform: translateX(-50%);
width: 40px; height: 8px; border-radius: 50%;
background: rgba(0,0,0,0.28);
filter: blur(2px);
animation: shadowPulse 1.8s ease-in-out infinite;
animation-delay: var(--delay, 0s);
}
@keyframes bob{
0%{   transform: translateY(0) rotate(0deg); }
50%{  transform: translateY(-10px) rotate(-2deg); }
100%{ transform: translateY(0) rotate(0); }
}
@keyframes wiggle{
0%{   transform: rotate(0); }
25%{  transform: rotate(-8deg); }
50%{  transform: rotate(0) scale(1.04); }
75%{  transform: rotate(8deg); }
100%{ transform: rotate(0); }
}
@keyframes shadowPulse{
0%{   transform: translateX(-50%) scale(1);    opacity: .6; }
50%{  transform: translateX(-50%) scale(0.85); opacity: .4; }
100%{ transform: translateX(-50%) scale(1);    opacity: .6; }
}

/* === Manual panel (menu only, LEFT) === */
#manualPanel{
position: fixed;
left: 20px;
top: 90px;
bottom: 220px;
width: 360px;
overflow: auto;
text-align: left;
background: rgba(17,24,39,0.85);
border: 2px solid #334155;
border-radius: 16px;
box-shadow: 0 8px 24px rgba(0,0,0,0.35);
z-index: 2;
padding-bottom: 10px;
}
#manualPanel h3{
margin:0; padding:12px 16px; background:#0f172a; border-bottom:2px solid #334155; font-size:18px;
}
#manualPanel .section{
padding:10px 16px 4px;
border-bottom:1px dashed rgba(255,255,255,0.08);
}
#manualPanel .section:last-child{ border-bottom:none; }
#manualPanel ul{ margin:6px 0 6px 18px; padding:0; }
#manualPanel li{ margin:4px 0; line-height:1.35; }
#manualPanel .kbd{
display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.2);
background:#0b1220; font-size:12px;
}
@media (max-width: 1100px){
#manualPanel{ display:none; }
#dancerStage{ display:none; }
}
@media (max-height: 700px){
#manualPanel{ bottom: 140px; }
}

/* === STARTING SPLASH (Click to Play) === */
#startOverlay{
position: fixed;
inset: 0;
z-index: 9999;
display: flex;
align-items: center;
justify-content: center;
background:
linear-gradient(rgba(0,0,0,0.35), rgba(0,0,0,0.55)),
url('startinglayer.png') center center / cover no-repeat;
cursor: pointer;
}
#startOverlay .startText{
font-size: 42px;
font-weight: 800;
letter-spacing: 1px;
background: rgba(0,0,0,0.55);
padding: 14px 26px;
border: 2px solid #fff;
border-radius: 14px;
box-shadow: 0 10px 30px rgba(0,0,0,0.35);
text-shadow: 0 2px 12px rgba(255,255,255,0.25);
user-select: none;
-webkit-user-select: none;
animation: pulseText 1.6s ease-in-out infinite;
}
@keyframes pulseText{
0%{ transform: scale(1); opacity: 1; }
50%{ transform: scale(1.05); opacity: 0.92; }
100%{ transform: scale(1); opacity: 1; }
}

/* NEW: Timer & 2x banner & Emotes */
#matchTimer{ position:fixed; top:66px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.45);
  border:2px solid #fff; border-radius:10px; padding:6px 10px; z-index:6; font-weight:700; letter-spacing:.5px; display:none; }
#overtimeBanner{ position:fixed; top:110px; left:50%; transform:translateX(-50%); background:linear-gradient(90deg,#7c3aed,#06b6d4);
  border:2px solid #fff; border-radius:12px; padding:8px 16px; z-index:6; display:none; font-weight:800; box-shadow:0 10px 30px rgba(0,0,0,.35); }
#emoteTray{position:fixed;left:20px;bottom:160px;display:none;gap:8px;z-index:6;}
.emote-btn{font-size:20px;border:2px solid #fff;background:#0b1220;border-radius:10px;padding:6px 8px;cursor:pointer;}
.emote-btn:disabled{opacity:.5;cursor:not-allowed;}
.emote-bubble{position:fixed;font-size:28px;padding:6px 10px;border-radius:14px;background:rgba(0,0,0,.5);border:2px solid #fff;transform:translate(-50%,-100%);pointer-events:none;z-index:7;animation:emotePop 1.3s ease-out forwards;}
@keyframes emotePop{0%{opacity:0;transform:translate(-50%,-80%) scale(.8);}10%{opacity:1;transform:translate(-50%,-100%) scale(1);}70%{opacity:1;transform:translate(-50%,-125%) scale(1);}100%{opacity:0;transform:translate(-50%,-140%) scale(1);}}
/* NEW: Deck summary chips */
#deckSummary{max-width:540px;margin:0 auto;text-align:left;}
#deckSummary .slots{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px;}
.slotChip{padding:4px 8px;border-radius:10px;border:1px solid #94a3b8;background:#0b1220;font-size:12px;}
.deck-toggle{margin-top:6px;padding:6px 10px;border-radius:8px;border:2px solid #fff;background:#0ea5e9;color:#fff;cursor:pointer;}
.deck-toggle.remove{background:#ef4444;}
</style>

<!-- Firebase compat SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
</head>
<body>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6444487225655573"
     crossorigin="anonymous"></script>
<!-- VERT -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6444487225655573"
     data-ad-slot="4380078490"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<!-- Background music (loop) ‚Äî ADDED -->
<audio id="bgm" src="mixkit-the-boss-479.mp3" loop preload="auto" playsinline></audio>

<!-- STARTING SPLASH (Click to Play) -->
<div id="startOverlay" title="Click to Play">
<div class="startText">Click to Play</div>
</div>

<!-- Top HUD -->
<div class="top-bar">
<div class="currency">
<div><img src="https://img.icons8.com/emoji/48/000000/coin-emoji.png" width="18" height="18"/> <span id="coinCount">0</span></div>
</div>
<div>
<span id="statusText">Idle</span>
<span id="onlineCount">Online: 0</span>
</div>
</div>

<!-- NEW: Timer/Banner (hidden in menu, shown in battle) -->
<div id="matchTimer" aria-live="polite">02:00</div>
<div id="overtimeBanner">2√ó ELIXIR</div>

<!-- MENU BACKGROUND (BUILT-IN) -->
<svg id="menuBg" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice">
<defs>
<linearGradient id="sky" x1="0" x2="0" y1="0" y2="1">
<stop offset="0%" stop-color="#0b1228"/>
<stop offset="60%" stop-color="#0b0f1c"/>
<stop offset="100%" stop-color="#09101e"/>
</linearGradient>
<linearGradient id="mist" x1="0" x2="0" y1="0" y2="1">
<stop offset="0%" stop-color="#1c2444" stop-opacity="0.0"/>
<stop offset="100%" stop-color="#1c2444" stop-opacity="0.35"/>
</linearGradient>
<linearGradient id="ground" x1="0" x2="0" y1="0" y2="1">
<stop offset="0%" stop-color="#0d1a2b"/>
<stop offset="100%" stop-color="#0a1524"/>
</linearGradient>
</defs>
<rect width="1920" height="1080" fill="url(#sky)"/>
<path d="M0,720 C300,640 500,700 800,660 C1150,610 1450,690 1920,620 L1920,1080 L0,1080 Z" fill="#0c162e"/>
<path d="M0,760 C350,700 550,760 850,740 C1200,710 1500,760 1920,700 L1920,1080 L0,1080 Z" fill="#0e1a35"/>
<rect y="650" width="1920" height="430" fill="url(#mist)"/>
<g transform="translate(960,520) scale(1.0)" fill="#1a2748" opacity="0.9">
<rect x="-260" y="-60" width="520" height="200"/>
<rect x="-330" y="-150" width="70" height="290"/><rect x="-330" y="-190" width="70" height="40"/>
<rect x="260" y="-150" width="70" height="290"/><rect x="260" y="-190" width="70" height="40"/>
<rect x="-90" y="-220" width="180" height="360"/><polygon points="-90,-220 0,-320 90,-220"/>
<g>
<rect x="-260" y="-60" width="30" height="30"/><rect x="-210" y="-60" width="30" height="30"/>
<rect x="-160" y="-60" width="30" height="30"/><rect x="-110" y="-60" width="30" height="30"/>
<rect x="-60" y="-60" width="30" height="30"/><rect x="-10" y="-60" width="30" height="30"/>
<rect x="40" y="-60" width="30" height="30"/><rect x="90" y="-60" width="30" height="30"/>
<rect x="140" y="-60" width="30" height="30"/><rect x="190" y="-60" width="30" height="30"/>
<rect x="240" y="-60" width="30" height="30"/>
</g>
</g>
<rect y="800" width="1920" height="280" fill="url(#ground)"/>
</svg>

<!-- MENU -->
<div id="menuScreen" class="screen">
<h2>üèÜ Flash Royale</h2>
<p>Name: <b id="playerNameLabel"></b></p>
<p>Your trophies: <b id="trophies">0</b></p>

<button id="battleBtn" class="battle-btn" onclick="findMatch()">BATTLE</button>
<button id="cancelBtn" class="cancel-btn" onclick="cancelSearch()">Cancel</button>

<h2>Your Deck</h2>
<!-- NEW: Deck summary -->
<div id="deckSummary">
  <div><b>Slots:</b> <span id="deckCount">0</span>/8</div>
  <div class="slots" id="deckSlots"></div>
</div>

<div class="deck" id="deck"></div>

<h2>Shop</h2>
<div class="shop" id="shop"></div>

<!-- GLOBAL LEADERBOARD (menu-only, right side) -->
<div class="leaderboard" id="leaderboard">
<h3>üåç Global Leaderboard (Trophies)</h3>
<div id="leaderboardRows"></div>
</div>

<!-- Manual panel (menu-only, LEFT) -->
<aside id="manualPanel" aria-label="Game Manual">
<h3>üìñ Quick Manual</h3>

<div class="section">
<strong>How to Start</strong>
<ul>
<li>Hit <span class="kbd">BATTLE</span> to join the queue. The game makes strict 1v1 rooms‚Äîtwo per room, multiple rooms supported.</li>
<li>If no one‚Äôs ready yet, you‚Äôll see <em>Searching‚Ä¶</em> until another player joins.</li>
<li>Your name (filtered) shows near your king tower.</li>
</ul>
</div>

<div class="section">
<strong>Placing Units & Spells</strong>
<ul>
<li>Click a card in your hand, then click to place. Units must be placed on your half; <b>spells</b> can be cast <b>anywhere</b>.</li>
<li><b>Pocketing:</b> destroy an enemy lane tower to unlock placement on that lane of the enemy side.</li>
<li>Units will prioritize fighting enemy units first before pushing towers.</li>
<li><b>Fireball</b> and <b>Arrows</b> are area-damage spells.</li>
</ul>
</div>

<div class="section">
<strong>Elixir & Cards</strong>
<ul>
<li>Elixir bar holds 10 segments; you gain +1 every 2 seconds (max 10). Overtime: 2√ó elixir.</li>
<li>Your battle hand shows 4 of your 8 deck cards; when you use one it rotates to the back.</li>
<li>Used cards have a 5s cooldown before you can select them again.</li>
</ul>
</div>

<div class="section">
<strong>Towers & Win</strong>
<ul>
<li>Two side towers + one king tower per side. Towers shoot back automatically.</li>
<li><i>Note:</i> towers do slightly less damage now for longer trades.</li>
<li>Destroy the opponent‚Äôs king tower to win the match.</li>
<li><b>At 2:00</b> if you‚Äôve taken one enemy lane tower while both of yours are intact, you win. Otherwise 2√ó elixir starts.</li>
<li>Win rewards: +100 coins, +5 trophies.</li>
</ul>
</div>

<div class="section">
<strong>Shop & Coins</strong>
<ul>
<li>Earn coins from wins and buy new characters or spells in the shop.</li>
<li>Everyone starts with 400 coins and a few starter cards.</li>
</ul>
</div>

<div class="section">
<strong>Reconnect & Cleanup</strong>
<ul>
<li>If you refresh or disconnect, you can rejoin your active room.</li>
<li>Rooms auto-delete when the game ends or both players go inactive.</li>
<li>Leaderboard on the right shows global trophies (top 20).</li>
</ul>
</div>

<div class="section">
<strong>Levels</strong>
<ul>
<li>Cards start at <b>Lv 1</b> (max <b>Lv 15</b>).</li>
<li>Use coins to upgrade in your Deck. Costs scale: 100 √ó current level.</li>
<li>Each level gives ~<b>+8%</b> HP & damage (spells: damage scales).</li>
</ul>
</div>
</aside>

<!-- Dancing Avatars (menu only) -->
<div id="dancerStage" aria-hidden="true">
<div class="dancer" style="--delay:0.00s"><span>üï∫</span></div>
<div class="dancer" style="--delay:0.12s"><span>üíÉ</span></div>
<div class="dancer" style="--delay:0.24s"><span>üßô‚Äç‚ôÇÔ∏è</span></div>
<div class="dancer" style="--delay:0.36s"><span>üßù‚Äç‚ôÄÔ∏è</span></div>
<div class="dancer" style="--delay:0.48s"><span>üõ°Ô∏è</span></div>
<div class="dancer" style="--delay:0.60s"><span>üê≤</span></div>
</div>
</div>

<!-- BATTLE -->
<div id="battleScreen" class="screen">
<canvas id="battleCanvas" width="800" height="700"></canvas>
</div>

<!-- Battle UI -->
<div id="cardBar"></div>
<div id="elixirBar"></div>
<!-- NEW: Emote tray -->
<div id="emoteTray">
  <button class="emote-btn" data-emote="üòÄ">üòÄ</button>
  <button class="emote-btn" data-emote="üò°">üò°</button>
  <button class="emote-btn" data-emote="üò≠">üò≠</button>
  <button class="emote-btn" data-emote="üëç">üëç</button>
</div>

<!-- Result -->
<div id="resultScreen">
<h1 id="resultText"></h1>
<p id="rewardText"></p>
<button onclick="returnToMenu()">OK</button>
</div>

<!-- CHANGELOG MODAL -->
<div id="changelogOverlay" role="dialog" aria-modal="true" aria-labelledby="changelogTitle">
<div id="changelogModal">
<button id="changelogClose" aria-label="Close changelog">√ó</button>
<h3 id="changelogTitle">What‚Äôs new in Flash Royale</h3>
<ul id="changelogList">
<li>Scripted and brought to you by Chace, enjoy!</li>
<li>Season Pass soon!</li>
<li>Tower AI that shoots back; health bars on towers &amp; units.</li>
<li>Strict 1v1 matchmaking with multiple simultaneous rooms.</li>
<li>Elixir bar (10 segments, +1 per 2s), 5s card cooldown after use.</li>
<li>Shop with 24+ characters &amp; spells; +100 coins &amp; +5 trophies on win.</li>
<li>Rejoin after refresh; rooms auto-clean when both players leave.</li>
<li>Player names shown by king castles; placement only on your half (spells anywhere).</li>
<li>NEW: Spells (Fireball, Arrows), unit-vs-unit priority, softer tower damage, Skeleton Army spawns a swarm.</li>
<li>Levels: cards &amp; spells up to Lv 15; upgrades cost coins and persist.</li>
</ul>
<div id="changelogHint">Click √ó to close</div>
</div>
</div>

<script>
/************ Firebase Init ************/
const firebaseConfig = {
apiKey: "AIzaSyA3FUH9RZiQ9IRChNpGqNrgjt2r5AA5RF8",
authDomain: "flash-royale-a92c0.firebaseapp.com",
databaseURL: "https://flash-royale-a92c0-default-rtdb.firebaseio.com",
projectId: "flash-royale-a92c0",
storageBucket: "flash-royale-a92c0.appspot.com",
messagingSenderId: "703977930640",
appId: "1:703977930640:web:a4f70deb5bbe508aec7d15",
measurementId: "G-61B7P6WEL0"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/************ Name Filter ************/
function normalizeForFilter(s){
if(!s) return "";
s = (""+s).toLowerCase();
const map = {'0':'o','1':'i','!':'i','3':'e','4':'a','@':'a','$':'s','5':'s','7':'t','8':'b','9':'g'};
s = s.replace(/[0!134@5$789]/g, ch => map[ch] || ch);
s = s.replace(/[^a-z0-9]/g, "");
s = s.replace(/([a-z0-9])\1{1,}/g, "$1$1");
return s;
}
const bannedB64 = [
"ZnVjaw==","c2hpdA==","Yml0Y2g=","Y3VudA==","ZGljaw==","cHVzc3k=","YXNz","YXNzaG9sZQ==","YmFzdGFyZA==",
"ZGFtbg==","c3Vja2Vy","c2x1QA==".replace('@','d'),"Z2F5","bmF6aQ==","Y3JhcA==","YmVhbg==","cmlt","a2lsbA=="
];
const bannedWords = bannedB64.map(b => atob(b));
function containsBannedWord(name){
const n = normalizeForFilter(name);
if(!n) return false;
for(const w of bannedWords){ if(n.includes(w)) return true; }
return false;
}
function sanitizeNameBasic(s){ return (s||"").replace(/[^a-zA-Z0-9]/g,"").substring(0,6); }
function requestCleanName(){
for(let i=0;i<3;i++){
const raw = prompt("Enter your player name (max 6 letters/numbers):","");
const cleaned = sanitizeNameBasic(raw);
if(cleaned && !containsBannedWord(cleaned)) return cleaned;
alert("That name isn't allowed. Please choose another.");
}
return "Anon";
}

/************ Player & Presence ************/
let playerId = localStorage.getItem("playerId");
if(!playerId){ playerId="player-"+Math.floor(Math.random()*10000); localStorage.setItem("playerId",playerId); }

let playerName = localStorage.getItem("playerName");
if(!playerName){
playerName = requestCleanName();
localStorage.setItem("playerName",playerName);
}else{
if(containsBannedWord(playerName) || !/^[a-zA-Z0-9]{1,6}$/.test(playerName)){
playerName = requestCleanName();
localStorage.setItem("playerName",playerName);
}
}
document.getElementById("playerNameLabel").innerText = playerName;

const playerRef = db.ref("players/"+playerId);

// Initialize if missing; start with 400 coins
playerRef.once("value").then(snap=>{
if(!snap.exists()){
playerRef.set({
name: playerName, online: true, disconnected: false,
coins: 400, trophies: 0,
ownedCards: { "Knight": true, "Archer": true, "Golem": true, "Dragon": true }
});
} else {
const p = snap.val()||{};
const updates = { name:playerName, online:true, disconnected:false };
if(p.coins===undefined || p.coins===null) updates.coins = 400;
playerRef.update(updates);
}
// Ensure levels exist (starter cards at level 1)
const starters = { "Knight":1, "Archer":1, "Golem":1, "Dragon":1 };
playerRef.child("levels").transaction(lv=>{
  lv = lv || {};
  for(const k in starters){ if(!lv[k]) lv[k] = 1; }
  return lv;
});
});

// HUD sync
playerRef.on("value", s=>{
const p = s.val()||{};
document.getElementById("coinCount").innerText = p.coins||0;
document.getElementById("trophies").innerText = p.trophies||0;
});

// Online count
db.ref("players").on("value", snap=>{
let online=0; snap.forEach(c=>{ if(c.val() && c.val().online) online++; });
document.getElementById("onlineCount").innerText = "Online: "+online;
});

// Presence flags
playerRef.onDisconnect().update({ online:false, disconnected:true });

/************ Cards (24+ total) ************/
const allCards = [
/* Troops */
{name:"Knight",hp:200,maxHp:200,dmg:20,range:25,cost:3,speed:2,img:"https://img.icons8.com/color/96/knight.png", price:0},
{name:"Archer",hp:120,maxHp:120,dmg:15,range:120,cost:3,speed:2,img:"https://img.icons8.com/color/96/bow.png", price:0},
{name:"Golem",hp:400,maxHp:400,dmg:30,range:25,cost:6,speed:1,img:"https://img.icons8.com/color/96/rock.png", price:0},
{name:"Dragon",hp:150,maxHp:150,dmg:40,range:100,cost:5,speed:3,img:"https://img.icons8.com/color/96/dragon.png", price:0},

{name:"Wizard",hp:160,maxHp:160,dmg:35,range:150,cost:5,speed:2,img:"https://img.icons8.com/color/96/wizard.png", price:500},
{name:"Goblin",hp:90,maxHp:90,dmg:12,range:25,cost:2,speed:4,img:"https://img.icons8.com/color/96/goblin.png", price:200},
{name:"Barbarian",hp:220,maxHp:220,dmg:25,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/barbarian.png", price:400},
{name:"Ice Spirit",hp:80,maxHp:80,dmg:10,range:20,cost:1,speed:5,img:"https://img.icons8.com/color/96/snowflake.png", price:150},
{name:"Giant",hp:600,maxHp:600,dmg:45,range:25,cost:7,speed:1,img:"https://img.icons8.com/color/96/giant.png", price:700},
{name:"Musketeer",hp:140,maxHp:140,dmg:30,range:200,cost:4,speed:2,img:"https://img.icons8.com/color/96/musket.png", price:450},
{name:"Prince",hp:280,maxHp:280,dmg:50,range:25,cost:5,speed:3,img:"https://img.icons8.com/color/96/prince.png", price:600},
{name:"Dark Knight",hp:260,maxHp:260,dmg:35,range:30,cost:5,speed:3,img:"https://img.icons8.com/color/96/darth-vader.png", price:600},
{name:"Healer",hp:150,maxHp:150,dmg:0,range:60,cost:4,speed:2,img:"https://img.icons8.com/color/96/angel.png", price:400},
{name:"Bomber",hp:110,maxHp:110,dmg:45,range:60,cost:3,speed:2,img:"https://img.icons8.com/color/96/bomb.png", price:300},
{name:"Skeleton Army",hp:35,maxHp:35,dmg:7,range:20,cost:3,speed:2.4,img:"https://img.icons8.com/color/96/skeleton.png", price:250},
{name:"Valkyrie",hp:260,maxHp:260,dmg:40,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/valkyrie.png", price:450},
{name:"Hog Rider",hp:280,maxHp:280,dmg:55,range:25,cost:4,speed:4,img:"https://img.icons8.com/color/96/boar.png", price:500},
{name:"Electro Spirit",hp:100,maxHp:100,dmg:20,range:60,cost:2,speed:4,img:"https://img.icons8.com/color/96/lightning-bolt.png", price:250},
{name:"Baby Dragon",hp:180,maxHp:180,dmg:35,range:80,cost:4,speed:3,img:"https://img.icons8.com/color/96/baby-dragon.png", price:500},
{name:"Pekka",hp:700,maxHp:700,dmg:80,range:25,cost:8,speed:1,img:"https://img.icons8.com/color/96/robot.png", price:800},
{name:"Bandit",hp:200,maxHp:200,dmg:40,range:25,cost:4,speed:5,img:"https://img.icons8.com/color/96/ninja.png", price:500},
{name:"Witch",hp:160,maxHp:160,dmg:25,range:180,cost:5,speed:2,img:"https://img.icons8.com/color/96/witch.png", price:500},
{name:"Bowler",hp:300,maxHp:300,dmg:35,range:150,cost:6,speed:2,img:"https://img.icons8.com/color/96/bowling-ball.png", price:600},
{name:"Hunter",hp:200,maxHp:200,dmg:50,range:100,cost:4,speed:3,img:"https://img.icons8.com/color/96/shotgun.png", price:500},
{name:"Mega Minion",hp:140,maxHp:140,dmg:30,range:50,cost:3,speed:3,img:"https://img.icons8.com/color/96/minion.png", price:350},

/* Spells */
{name:"Fireball", type:"spell", dmg:180, radius:70, cost:4, img:"https://img.icons8.com/color/96/fireball.png", price:450},
{name:"Arrows",   type:"spell", dmg:90,  radius:120, cost:3, img:"https://img.icons8.com/color/96/archers-bow.png", price:350}
];

/************ Levels ************/
const MAX_LEVEL = 15;
function upgradeCostFor(level){
  level = Math.max(1, Math.min(MAX_LEVEL-1, level));
  return 100 * level; // 1->2:100 ... 14->15:1400
}
function levelMultiplier(level){
  return 1 + 0.08 * (Math.max(1, Math.min(MAX_LEVEL, level)) - 1);
}

/* NEW: Sprites (per-card avatars) */
const spriteCache = {};
const spriteUrlOverrides = {
  "Skeleton": "https://img.icons8.com/color/96/skeleton.png"
};
function spriteForName(name){
  if (spriteCache[name]) return spriteCache[name];
  const card = allCards.find(c => c.name === name);
  const url = (card && card.img) || spriteUrlOverrides[name] ||
    "data:image/svg+xml;utf8," + encodeURIComponent(
      `<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'>
         <rect width='64' height='64' rx='10' ry='10' fill='#334155'/>
         <circle cx='32' cy='32' r='18' fill='#94a3b8'/>
       </svg>`
    );
  const img = new Image();
  img.src = url;
  spriteCache[name] = img;
  return img;
}
function spriteSizeFor(name){
  const card = allCards.find(c => c.name === name);
  const cost = card?.cost ?? 3;
  return Math.max(34, Math.min(52, 38 + (cost - 3) * 2));
}

/* NEW: Deck + Hand rotation state */
let playerLevels = {};
let playerDeck = [];           // stored in DB
let handQueue = [];            // rotating queue in battle (from deck)
let playerOwnedCached = {};    // to build deck UI

/* helper: ensure initial deck from owned if missing */
function ensureInitialDeck(owned){
  const names = Object.keys(owned||{});
  const initial=[];
  for(let i=0;i<names.length && initial.length<8;i++) initial.push(names[i]);
  return initial;
}

playerRef.child("levels").on("value", (s)=>{
  playerLevels = s.val() || {};
  // Re-render deck to reflect new levels / costs
  playerRef.once("value").then(snap=>{
    const p = snap.val() || {};
    renderDeck(p.ownedCards||{}, p.coins||0);
  });
});

/* Deck + Shop render */
function renderDeck(owned, coins){
const deckEl = document.getElementById("deck");
const deckSlots = document.getElementById("deckSlots");
const deckCountEl = document.getElementById("deckCount");
playerOwnedCached = owned || {};
deckEl.innerHTML="";
deckSlots.innerHTML="";

playerRef.child("deck").once("value").then(s=>{
  playerDeck = s.val() || ensureInitialDeck(playerOwnedCached);
  if(playerDeck.length>8) playerDeck=playerDeck.slice(0,8);
  deckCountEl.innerText = playerDeck.length;
  playerDeck.forEach(nm=>{
    const chip=document.createElement("span");
    chip.className="slotChip";
    chip.textContent=nm;
    deckSlots.appendChild(chip);
  });

  allCards.forEach(c=>{
    if(!playerOwnedCached[c.name]) return;
    const lvl = Math.max(1, Math.min(MAX_LEVEL, (playerLevels && playerLevels[c.name]) || 1));
    const canLevel = lvl < MAX_LEVEL;
    const cost = canLevel ? upgradeCostFor(lvl) : 0;

    const d=document.createElement("div");
    d.className="card";
    const inDeck = playerDeck.includes(c.name);
    d.innerHTML = `
      <div class="elixir-cost">${c.cost}</div>
      <div class="level-badge">Lv ${lvl}</div>
      <img src="${c.img}">
      <b>${c.name}</b>
      ${
        canLevel
        ? `<button class="upgrade-btn" data-name="${c.name}" ${ (coins>=cost) ? "" : "disabled" }>Upgrade (${cost}ü™ô)</button>`
        : `<div class="owned">Max Level</div>`
      }
      <button class="deck-toggle ${inDeck?'remove':''}" data-name="${c.name}">
        ${inDeck?'Remove from Deck':'Add to Deck'}
      </button>
    `;
    if(canLevel){
      const btn = d.querySelector(".upgrade-btn");
      btn.onclick = ()=>{
        btn.disabled = true;
        const current = Math.max(1, Math.min(MAX_LEVEL, (playerLevels && playerLevels[c.name]) || 1));
        if(current >= MAX_LEVEL) return;
        const costNow = upgradeCostFor(current);
        playerRef.child("coins").transaction(v=>{
          v = v || 0;
          if(v < costNow) return;      // abort
          return v - costNow;
        }, (err, committed)=>{
          if(err || !committed){
            btn.disabled = false;
            return alert("Not enough coins or network error.");
          }
          playerRef.child("levels/"+c.name).transaction(lv=>{
            lv = Math.max(1, Math.min(MAX_LEVEL, lv || 1));
            if(lv >= MAX_LEVEL) return lv;
            return lv + 1;
          });
        });
      };
    }
    const toggle = d.querySelector(".deck-toggle");
    toggle.onclick = ()=>{
      const nm=c.name;
      const inD = playerDeck.includes(nm);
      if(inD){
        playerDeck = playerDeck.filter(x=>x!==nm);
      } else {
        if(playerDeck.length>=8) return alert("Your deck can only hold 8 cards.");
        playerDeck.push(nm);
      }
      playerRef.child("deck").set(playerDeck).then(()=>renderDeck(playerOwnedCached, coins));
    };

    deckEl.appendChild(d);
  });
});
}

function renderShop(owned, coins){
const shop = document.getElementById("shop"); shop.innerHTML="";
allCards.forEach(c=>{
if(c.price<=0) return;
const ownedFlag = !!owned[c.name];
const el = document.createElement("div");
el.className="card";
el.innerHTML = `
         <div class="elixir-cost">${c.cost}</div>
         <img src="${c.img}">
         <b>${c.name}</b>
         <div class="price-tag">${c.price} ü™ô</div>
         <button class="${ownedFlag?'owned':'buy-btn'}" ${ownedFlag?'disabled':''}>${ownedFlag?'Owned':'Buy'}</button>
       `;
if(!ownedFlag){
const btn = el.querySelector('.buy-btn');
btn.onclick = ()=>{
btn.disabled = true; btn.textContent = "Buying...";
playerRef.child("coins").transaction(v=>{
v=v||0; if(v < c.price) return; return v - c.price;
}, (err, committed)=>{
if(err || !committed){
btn.disabled=false; btn.textContent="Buy";
alert("Not enough coins or network error.");
return;
}
playerRef.child("ownedCards/"+c.name).set(true);
// ensure new purchases start at level 1
playerRef.child("levels/"+c.name).transaction(lv => lv || 1);
// NEW: auto-add to deck if there is room
playerRef.child("deck").transaction(d=>{
  d=d||[];
  if(!d.includes(c.name) && d.length<8) d.push(c.name);
  return d;
});
});
};
}
shop.appendChild(el);
});
}
playerRef.on("value", s=>{
const p=s.val()||{}; const owned=p.ownedCards||{};
renderDeck(owned, p.coins||0); renderShop(owned, p.coins||0);
});

/************ Elixir ************/
let elixir=0, maxElixir=10, elixirRegenRate=2000, lastElixirTime=Date.now();
function initElixirBar(){
const bar=document.getElementById("elixirBar"); bar.innerHTML="";
for(let i=0;i<maxElixir;i++){ const seg=document.createElement("div"); seg.className="elixir-segment"; seg.id="elixir-"+i; bar.appendChild(seg); }
}
function updateElixir(){
const now=Date.now();
if(now-lastElixirTime>=elixirRegenRate && elixir<maxElixir){ elixir++; lastElixirTime=now; }
for(let i=0;i<maxElixir;i++){ const seg=document.getElementById("elixir-"+i); if(seg) seg.classList.toggle("elixir-filled", i<elixir); }
}
setInterval(updateElixir, 200);

/************ Matchmaking (strict 1v1; multiple rooms) ************/
let roomId=null, mySide=null, searching=false, battleReady=false, isHost=false, hostId=null;
let roomRef=null, actionsRef=null, stateRef=null, roomPlayersRef=null, queueAdded=false, pairInterval=null;
/* NEW: Emotes ref and timer meta */
let emoteRef=null;
let matchStartTs=0, timerRunning=false, twoMinutes=120000, twoX=false;

/* NEW: Pocket flags (computed from towers) */
let pocketBlue={left:false,right:false};
let pocketRed ={left:false,right:false};

function findMatch(){
document.getElementById("statusText").innerText="Searching...";
document.getElementById("battleBtn").style.display="none";
document.getElementById("cancelBtn").style.display="inline-block";
searching=true;

const myQueueRef = db.ref("queue/"+playerId);
if(!queueAdded){
myQueueRef.set({ name:playerName, ts:firebase.database.ServerValue.TIMESTAMP, searching:true });
myQueueRef.onDisconnect().remove();
queueAdded=true;
}
attemptPair();
if(pairInterval) clearInterval(pairInterval);
pairInterval = setInterval(()=>{ if(searching && !roomId) attemptPair(); }, 1500);

db.ref("rooms").on("child_added", snap=>{
if(!searching || roomId) return;
const r=snap.val();
if(r && r.players && r.players[playerId]){
roomId=snap.key;
mySide = r.players[playerId].side || "red";
startBattle();
}
});
}

function attemptPair(){
db.ref("queue").once("value").then(snap=>{
if(!searching || roomId) return;
const q = snap.val()||{};
let cand=null, bestTs=Infinity;
Object.keys(q).forEach(k=>{
if(k===playerId) return;
const it=q[k]; if(!it || it.claimed) return;
const ts = typeof it.ts==='number' ? it.ts : Date.now();
if(ts<bestTs){ bestTs=ts; cand=k; }
});
if(!cand) return;

db.ref("queue/"+cand+"/claimed").transaction(val=>{
if(val) return; return playerId;
}, async (err, committed, snap2)=>{
if(err || !committed || snap2.val()!==playerId){ return; }
const oppNameSnap = await db.ref("players/"+cand+"/name").once("value");
const oppName = oppNameSnap.val() || "Opponent";

roomId = "room-"+Date.now()+"-"+Math.floor(Math.random()*1000);
mySide = "blue";
const roomData={
createdAt: firebase.database.ServerValue.TIMESTAMP,
state:"active",
host: playerId,
players:{
[playerId]:{connected:true,side:"blue",name:playerName},
[cand]:{connected:true,side:"red",name:oppName}
}
};
db.ref("rooms/"+roomId).set(roomData).then(()=>{
db.ref("queue/"+cand).remove();
db.ref("queue/"+playerId).remove();
startBattle();
});
});
});
}

function cancelSearch(){
searching=false;
if(pairInterval){ clearInterval(pairInterval); pairInterval=null; }
db.ref("queue/"+playerId).remove();
queueAdded=false;
document.getElementById("statusText").innerText="Idle";
document.getElementById("battleBtn").style.display="inline-block";
document.getElementById("cancelBtn").style.display="none";
}

function tryRejoinRoom(){
db.ref("rooms").once("value").then(s=>{
s.forEach(r=>{
const val=r.val();
if(val && val.state==="active" && val.players && val.players[playerId]){
roomId=r.key; mySide=val.players[playerId].side||"red";
startBattle();
}
});
});
}
playerRef.once("value").then(s=>{
const p=s.val()||{};
if(p.disconnected){ tryRejoinRoom(); playerRef.update({disconnected:false, online:true}); }
});

/************ Battle ************/
const canvas=document.getElementById("battleCanvas");
const ctx=canvas.getContext("2d");
ctx.imageSmoothingEnabled = true; // NEW
const towerImg=new Image(); towerImg.src="mini-castle.png";

// Arena geometry (pathing)
const RIVER_H = 40;
const BRIDGE_W = 140;
const RIVER_Y = canvas.height/2 - RIVER_H/2;
const BRIDGE_CENTERS = [220, 580]; // x centers

// State
let towers=[], units=[], selectedCard=null;
let placementCircle=null, lastMouse={x:canvas.width/2, y:canvas.height*0.75};
const cardCooldowns={}; // name -> timestamp
let projectiles=[]; // tower shots
let gameOver=false;
let nameBlue="Blue", nameRed="Red";
let pendingActionKeys=new Set();
let lastPublishTime=0, PUBLISH_MS=100;
/* NEW: room levels cache */
let roomLevelsCache = {};

/* === Levels cache for room (used by host when spawning) === */
async function preloadLevelsForRoom(){
  if(!roomRef) return;
  const pSnap = await roomRef.child("players").once("value");
  const ids = [];
  pSnap.forEach(ch => ids.push(ch.key));
  await Promise.all(ids.map(async (id)=>{
    const lvSnap = await db.ref("players/"+id+"/levels").once("value");
    roomLevelsCache[id] = lvSnap.val() || {};
  }));
}

/* NEW: helper deck ‚Üí hand setup */
function buildInitialHandQueue(deck, owned){
  const d = (deck || []).filter(nm => owned && owned[nm]);
  if(d.length === 0){
    // fallback: use any owned up to 8
    return Object.keys(owned||{}).slice(0,8);
  }
  return d.slice(0, 8); // cap
}

/* === Hand (owned cards) with rotation of 4 === */
function renderHand(owned){
  const bar=document.getElementById("cardBar"); bar.innerHTML="";
  const toShow = handQueue.slice(0,4);
  toShow.forEach(nm=>{
    const card = allCards.find(c=>c.name===nm);
    if(!card) return;
    const lvl = Math.max(1, Math.min(MAX_LEVEL, (playerLevels && playerLevels[nm]) || 1));
    const d=document.createElement("div");
    d.className="card";
    d.innerHTML=`<div class="elixir-cost">${card.cost}</div><div class="level-badge">Lv ${lvl}</div><img src="${card.img}"><b>${card.name}</b>`;
    const now=Date.now(); const cd=cardCooldowns[card.name]||0;
    if(cd>now) d.classList.add("cooldown");
    d.onclick=()=>{
      if((cardCooldowns[card.name]||0) > Date.now()) return;
      selectedCard=card;
      document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
      d.classList.add("selected");
      let y=lastMouse.y;
      if(selectedCard && selectedCard.type==="spell"){
        placementCircle={x:lastMouse.x, y:lastMouse.y}; // anywhere
      }else{
        // placement circle respects pocketing
        placementCircle = clampPlacement(lastMouse.x, lastMouse.y, selectedCard);
      }
    };
    bar.appendChild(d);
  });
}
function refreshCooldownStyles(){
const now=Date.now();
document.querySelectorAll("#cardBar .card").forEach(el=>{
const nameEl=el.querySelector("b"); if(!nameEl) return;
const nm=nameEl.textContent;
el.classList.toggle("cooldown", (cardCooldowns[nm]||0) > now);
});
}

/* NEW: lane helper for pocketing */
function laneFromX(x){ return x<canvas.width/2 ? "left" : "right"; }

/* NEW: placement clamp with pocket rules */
function clampPlacement(x,y,card){
  if(card && card.type==="spell"){
    // spells can go anywhere within canvas bounds
    x=Math.max(20,Math.min(canvas.width-20,x));
    y=Math.max(20,Math.min(canvas.height-20,y));
    return {x,y};
  }
  let nx=x, ny=y;
  const lane = laneFromX(nx);
  if(mySide==="blue"){
    // normally your half (bottom). allow enemy half if pocket unlocked on that lane
    if(ny<canvas.height/2 && !(lane==="left"?pocketBlue.left:pocketBlue.right)) ny=canvas.height/2;
  } else {
    // red normally top half; allow bottom if pocket unlocked for red
    if(ny>canvas.height/2 && !(lane==="left"?pocketRed.left:pocketRed.right)) ny=canvas.height/2;
  }
  nx=Math.max(20,Math.min(canvas.width-20,nx));
  ny=Math.max(20,Math.min(canvas.height-20,ny));
  return {x:nx,y:ny};
}

/* Mouse move */
canvas.addEventListener("mousemove", e=>{
const r=canvas.getBoundingClientRect();
lastMouse.x = e.clientX - r.left;
lastMouse.y = e.clientY - r.top;
if(!selectedCard){ placementCircle=null; return; }
if(selectedCard.type==="spell"){
  placementCircle = {x:lastMouse.x, y:lastMouse.y}; // anywhere
}else{
  placementCircle = clampPlacement(lastMouse.x, lastMouse.y, selectedCard);
}
});

/* Drop card ‚Üí push action, rotate hand */
canvas.addEventListener("click", e=>{
if(!battleReady) return;
if(!selectedCard) return;
const rect=canvas.getBoundingClientRect();
let x=e.clientX-rect.left, y=e.clientY-rect.top;

({x,y} = clampPlacement(x,y, selectedCard));

if(elixir < selectedCard.cost) return;
elixir -= selectedCard.cost;
cardCooldowns[selectedCard.name]=Date.now()+5000;
refreshCooldownStyles();
db.ref("rooms/"+roomId+"/actions").push({
  player:playerId, card:selectedCard, x, y, timestamp:Date.now()
});

// rotate used card if in the first 4
const idx=handQueue.indexOf(selectedCard.name);
if(idx>-1){
  const used=handQueue.splice(idx,1)[0];
  handQueue.push(used);
  renderHand(/* uses global handQueue */ playerOwnedCached);
}

selectedCard=null; placementCircle=null;
document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
});

/* Drawing helpers */
function drawArena(){
const g=ctx.createLinearGradient(0,0,0,canvas.height);
g.addColorStop(0,"#0f2b1f"); g.addColorStop(0.5,"#123725"); g.addColorStop(1,"#0f2b1f");
ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

ctx.fillStyle="#243a5e";
ctx.fillRect(0, RIVER_Y, canvas.width, RIVER_H);

const bridges=[ {x:BRIDGE_CENTERS[0]-BRIDGE_W/2, y:RIVER_Y-6}, {x:BRIDGE_CENTERS[1]-BRIDGE_W/2, y:RIVER_Y-6} ];
ctx.fillStyle="#6e5537";
bridges.forEach(b=>{
ctx.fillRect(b.x, b.y, BRIDGE_W, RIVER_H+12);
ctx.fillStyle="#7a6040";
for(let i=0;i<BRIDGE_W;i+=18){ ctx.fillRect(b.x+i+2, b.y, 8, RIVER_H+12); }
ctx.fillStyle="#6e5537";
});

ctx.strokeStyle="rgba(255,255,255,0.15)"; ctx.lineWidth=2;
ctx.beginPath(); ctx.moveTo(0, canvas.height/3); ctx.lineTo(canvas.width, canvas.height/3); ctx.stroke();
ctx.beginPath(); ctx.moveTo(0, canvas.height*2/3); ctx.lineTo(canvas.width, canvas.height*2/3); ctx.stroke();

ctx.fillStyle="rgba(0,0,255,0.05)"; ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
ctx.fillStyle="rgba(255,0,0,0.05)"; ctx.fillRect(0, 0, canvas.width, canvas.height/2);
}

function drawTower(t){
const size = t.king ? 60 : 50;
if(towerImg.complete){ ctx.drawImage(towerImg, t.x-size/2, t.y-size/2, size, size); }
else{ ctx.fillStyle=t.side==="blue"?"#5ec8ff":"#ff6b6b"; ctx.fillRect(t.x-size/2, t.y-size/2, size, size); }
const maxHp = t.king?1000:600;
ctx.fillStyle="#900"; ctx.fillRect(t.x-28, t.y-(size/2)-10, 56, 6);
ctx.fillStyle="#3f3"; ctx.fillRect(t.x-28, t.y-(size/2)-10, 56*(Math.max(0,t.hp)/maxHp), 6);
}
function drawTowerName(t, nm){
if(!nm) return;
ctx.font='16px Arial'; ctx.textAlign='center'; ctx.lineWidth=3; ctx.strokeStyle='black';
const size = t.king ? 60 : 50;
const y = t.side==='blue' ? (t.y + size/2 + 18) : (t.y - size/2 - 14);
ctx.strokeText(nm, t.x, y);
ctx.fillStyle='white'; ctx.fillText(nm, t.x, y);
}

/* NEW: Sprite-based unit renderer */
function drawUnit(u){
  const img = spriteForName(u.name);
  const size = spriteSizeFor(u.name);
  const half = size / 2;

  // Soft shadow
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(u.x, u.y + half*0.60, half*0.70, half*0.35, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Gentle bob animation (seeded per unit)
  const t = Date.now() + (u.animSeed || 0);
  const bob = Math.sin(t / 180) * 3;

  // Draw the sprite centered at (x,y)
  ctx.save();
  ctx.translate(u.x, u.y - 6 + bob);
  if (u.side === "red") ctx.scale(-1, 1);

  if (img && img.complete && img.naturalWidth){
    ctx.drawImage(img, -half, -half, size, size);
  } else {
    ctx.fillStyle = (u.side==="blue") ? "#8de1ff" : "#ff7f7f";
    ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // HP bar
  ctx.fillStyle = "#900"; ctx.fillRect(u.x-15, u.y-24, 30, 5);
  ctx.fillStyle = "#3f3"; ctx.fillRect(u.x-15, u.y-24, 30*(u.hp/u.maxHp), 5);
}

/************ Simulation (host-only) ************/
function pickNearestBridgeX(x){
const a=BRIDGE_CENTERS[0], b=BRIDGE_CENTERS[1];
return (Math.abs(x-a) <= Math.abs(x-b)) ? a : b;
}

// PRIORITY: nearest enemy unit first; otherwise nearest enemy tower
function nearestEnemyUnit(u, maxR=9999){
  let best=null, bestD2=Infinity;
  const r2 = maxR*maxR;
  for(const v of units){
    if(v.side===u.side || v.hp<=0 || v===u) continue;
    const dx=v.x - u.x, dy=v.y - u.y;
    const d2 = dx*dx + dy*dy;
    if(d2 <= r2 && d2 < bestD2){ best=v; bestD2=d2; }
  }
  return best;
}

function nearestEnemyTower(u){
let best=null, bestD2=Infinity;
for(const t of towers){
if(t.side===u.side || t.hp<=0) continue;
const dx=t.x - u.x, dy=t.y - u.y;
const d2 = dx*dx + dy*dy;
if(d2 < bestD2){ best=t; bestD2=d2; }
}
return best;
}

/* NEW: Skeleton Army ‚Äî spread swarm with separation */
function spawnSkeletonHorde(side, x, y, ownerId, baseCard){
  const lvl = (roomLevelsCache[ownerId] && roomLevelsCache[ownerId][baseCard.name]) || 1;
  const mult = levelMultiplier(lvl);
  const count = 14;
  const baseRadius = 32;
  const swarmId = "swarm-"+Math.random().toString(36).slice(2,8);
  for(let i=0;i<count;i++){
    const ang = (i / count) * Math.PI*2;
    const jitter=(Math.random()*10-5);
    const sx = x + Math.cos(ang)*(baseRadius + jitter);
    const sy = y + Math.sin(ang)*(baseRadius + jitter);
    units.push({
      name:"Skeleton", swarm:swarmId,
      hp: Math.max(1, Math.floor(baseCard.hp * 0.8 * mult)),
      maxHp: Math.max(1, Math.floor(baseCard.maxHp * 0.8 * mult)),
      dmg: Math.max(1, Math.floor(baseCard.dmg * 1.0 * mult)),
      range: 20,
      speed: Math.max(0.7, baseCard.speed*0.95),
      side, x:sx, y:sy, cooldown:0, dir:(side==="blue" ? -1 : 1),
      pathStage:'toBridge', targetX: pickNearestBridgeX(x), targetY: (side==='blue' ? (RIVER_Y + RIVER_H + 8) : (RIVER_Y - 8)),
      goal: null, level: lvl,
      animSeed: Math.floor(Math.random()*1000) // NEW
    });
  }
}

/* NEW: basic separation to keep swarms spread */
function applySeparation(){
  const desired=22, maxPush=0.8;
  for(let i=0;i<units.length;i++){
    const a=units[i]; if(!a.swarm) continue;
    for(let j=i+1;j<units.length;j++){
      const b=units[j]; if(!b.swarm || b.swarm!==a.swarm) continue;
      const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy);
      if(d>0 && d<desired){
        const push=(desired-d)/desired * maxPush; const nx=dx/d, ny=dy/d;
        a.x -= nx*push; a.y -= ny*push;
        b.x += nx*push; b.y += ny*push;
      }
    }
  }
}

function spawnUnit(card, side, x, y, ownerId){
  // Spells are handled elsewhere
  if(card.type==="spell") return;

  if(card.name==="Skeleton Army"){
    return spawnSkeletonHorde(side, x, y, ownerId, card);
  }

  const lvl = (roomLevelsCache[ownerId] && roomLevelsCache[ownerId][card.name]) || 1;
  const mult = levelMultiplier(lvl);

  const slowFactor = 0.30; // slower
  const speed = Math.max(0.35, card.speed * slowFactor);
  const bridgeX = pickNearestBridgeX(x);
  const startTargetY = side==='blue' ? (RIVER_Y + RIVER_H + 8) : (RIVER_Y - 8);
  units.push({
    name:card.name,
    hp: Math.floor(card.hp * mult),
    maxHp: Math.floor(card.maxHp * mult),
    dmg: Math.max(1, Math.floor(card.dmg * mult)),
    range: card.range,
    speed, side, x, y, cooldown:0, dir:(side==="blue" ? -1 : 1),
    pathStage:'toBridge', targetX: bridgeX, targetY: startTargetY,
    goal: null, level: lvl,
    animSeed: Math.floor(Math.random()*1000) // NEW
  });
}

// Spells: Fireball, Arrows (AOE). Towers take reduced damage from spells.
function castSpell(card, side, x, y, ownerId){
  const lvl = (roomLevelsCache[ownerId] && roomLevelsCache[ownerId][card.name]) || 1;
  const mult = levelMultiplier(lvl);
  const dmg = Math.floor((card.dmg||0) * mult);
  const rad = card.radius || 80;

  // Damage enemy units in radius
  for(const u of units){
    if(u.side===side || u.hp<=0) continue;
    const dx=u.x-x, dy=u.y-y;
    if(dx*dx+dy*dy <= rad*rad){
      u.hp -= dmg;
    }
  }
  // Damage towers less (35% of spell dmg)
  const towerDmg = Math.floor(dmg * 0.35);
  for(const t of towers){
    if(t.side===side || t.hp<=0) continue;
    const dx=t.x-x, dy=t.y-y;
    if(dx*dx+dy*dy <= (rad+25)*(rad+25)){
      t.hp -= towerDmg;
    }
  }
}

function moveTowards(u,tx,ty){
const dx=tx-u.x, dy=ty-u.y;
const dist = Math.hypot(dx,dy);
if(dist <= u.speed){ u.x=tx; u.y=ty; return true; }
u.x += u.speed * dx/dist;
u.y += u.speed * dy/dist;
return false;
}

function updateUnits(){
applySeparation(); // NEW
units.forEach(u=>{
if(u.pathStage==='toBridge'){
if(moveTowards(u, u.targetX, u.targetY)){
u.pathStage='crossing';
u.targetY = (u.side==='blue') ? (RIVER_Y - 8) : (RIVER_Y + RIVER_H + 8);
}
return;
}
if(u.pathStage==='crossing'){
// While crossing, still react to enemies in range
const enemyClose = nearestEnemyUnit(u, Math.max(140, u.range||25) + 40);
if(enemyClose){
  const dx=enemyClose.x - u.x, dy=enemyClose.y - u.y;
  const dist = Math.hypot(dx,dy);
  const attackRange = Math.max(20, u.range||25);
  if(dist <= attackRange){
    if(u.cooldown<=0){
      enemyClose.hp -= u.dmg;
      u.cooldown = 30;
    }
  } else {
    moveTowards(u, enemyClose.x, enemyClose.y);
  }
  if(u.cooldown>0) u.cooldown--;
  return;
}

if(moveTowards(u, u.targetX, u.targetY)){
u.pathStage='toTarget';
}
return;
}

// MAIN COMBAT AI (prioritize enemy units)
let target = nearestEnemyUnit(u, 9999);
if(!target || target.hp<=0){
  target = nearestEnemyTower(u);
}
if(!target){ return; }

const dx=target.x - u.x, dy=target.y - u.y;
const dist = Math.hypot(dx,dy);
const attackRange = Math.max(20, u.range||25);

if(dist <= attackRange){
if(u.cooldown<=0){
target.hp -= u.dmg;
u.cooldown = 30; // ~0.5s
}
} else {
// move toward chosen target
moveTowards(u, target.x, target.y);
}

if(u.cooldown>0) u.cooldown--;
});

units = units.filter(u=>u.hp>0);
}

/* Tower AI (slightly reduced damage) */
function updateTowersAI(){
towers.forEach(t=>{
if(t.hp<=0) return;
t.cd = Math.max(0, (t.cd||0)-1);
const range = t.range || (t.king?250:200);
if(t.cd>0) return;

let best=null, bestD2=Infinity;
for(const u of units){
if(u.side===t.side) continue;
const dx=u.x - t.x, dy=u.y - t.y;
const d2=dx*dx+dy*dy;
if(d2 < range*range && d2 < bestD2){ best=u; bestD2=d2; }
}
if(best){
const speed=7;
const dx=best.x - t.x, dy=best.y - t.y;
const mag=Math.max(0.001, Math.hypot(dx,dy));
const vx=speed*dx/mag, vy=speed*dy/mag;
projectiles.push({x:t.x, y:t.y, vx, vy, dmg:(t.dmg|| (t.king?26:16)), side:t.side});
t.cd = t.cdMax || 60;
}
});
}
function updateProjectiles(){
const radius=5;
projectiles.forEach(p=>{
p.x += p.vx; p.y += p.vy;
for(const u of units){
if(u.side===p.side) continue;
const dx=u.x-p.x, dy=u.y-p.y;
if(dx*dx+dy*dy <= (radius+12)*(radius+12)){
u.hp -= p.dmg;
p.dead=true;
}
}
if(p.x<-20||p.x>canvas.width+20||p.y<-20||p.y>canvas.height+20) p.dead=true;
});
projectiles = projectiles.filter(p=>!p.dead);
}

/* NEW: compute pockets from tower hp */
function updatePocketFlags(){
  const redLeft  = towers.find(t=>t.side==="red" && !t.king && t.x<canvas.width/2);
  const redRight = towers.find(t=>t.side==="red" && !t.king && t.x>=canvas.width/2);
  const blueLeft = towers.find(t=>t.side==="blue" && !t.king && t.x<canvas.width/2);
  const blueRight= towers.find(t=>t.side==="blue" && !t.king && t.x>=canvas.width/2);
  pocketBlue.left  = !!(redLeft && redLeft.hp<=0);
  pocketBlue.right = !!(redRight&& redRight.hp<=0);
  pocketRed.left   = !!(blueLeft&& blueLeft.hp<=0);
  pocketRed.right  = !!(blueRight&& blueRight.hp<=0);
}

/* NEW: timer UI update (clients) */
function updateTimerUI(){
  if(!timerRunning) return;
  const el = document.getElementById('matchTimer');
  const left = Math.max(0, twoMinutes - (Date.now() - matchStartTs));
  const sec = Math.floor(left/1000);
  const m = String(Math.floor(sec/60)).padStart(2,'0');
  const s = String(sec%60).padStart(2,'0');
  el.textContent = m+":"+s;
}

/* NEW: tie-break then 2x elixir (host) */
function tieBreakOrOvertime(){
  // lane counts
  const redLaneAlive = towers.filter(t=>t.side==="red" && !t.king && t.hp>0).length;
  const blueLaneAlive= towers.filter(t=>t.side==="blue"&& !t.king && t.hp>0).length;

  const blueIntact = blueLaneAlive===2;
  const redIntact  = redLaneAlive===2;
  const redLostOne = redLaneAlive<=1;
  const blueLostOne= blueLaneAlive<=1;

  const blueWins = redLostOne && blueIntact;
  const redWins  = blueLostOne && redIntact;

  if(blueWins && !redWins){ endGame("Blue"); return; }
  if(redWins  && !blueWins){ endGame("Red");  return; }

  // Overtime (2x elixir)
  twoX=true;
  roomRef.child("meta/overtime").set(true); // clients will speed up their elixir
  const banner=document.getElementById("overtimeBanner");
  banner.style.display="block";
  setTimeout(()=>{ banner.style.display="none"; },1800);
}

/* host-only endGame writer */
function endGame(winnerColor){
if(gameOver) return; gameOver=true;
roomRef.child("state").set("ended");
roomRef.child("winner").set(winnerColor);
const iWon = (winnerColor==="Blue" && mySide==="blue") || (winnerColor==="Red" && mySide==="red");
if(iWon){
playerRef.child("coins").transaction(c=>(c||0)+100);
playerRef.child("trophies").transaction(t=>(t||0)+5);
}
document.getElementById("resultText").innerText = iWon ? "üèÜ Victory!" : "‚ùå Defeat";
document.getElementById("rewardText").innerText = iWon ? "+100 Coins, +5 Trophies" : "Better luck next time!";
document.getElementById("resultScreen").style.display="block";
}

/* leave room & maybe delete (unchanged) */
function leaveRoomAndMaybeDelete(){
if(!roomRef || !roomId) return;
const myPlayerNode = roomRef.child("players/"+playerId);
myPlayerNode.update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});
roomRef.child("players").once("value").then(s=>{
let any=false; s.forEach(p=>{ if(p.val() && p.val().connected) any=true; });
if(!any){ roomRef.remove(); }
});
}

window.addEventListener("beforeunload", ()=>{
playerRef.update({online:false, disconnected:true});
leaveRoomAndMaybeDelete();
});

/* Host/non-host wiring */
function attachHostListeners(){
actionsRef.on("child_added", snap=>{
const key=snap.key;
if(pendingActionKeys.has(key)) return;
pendingActionKeys.add(key);
const a=snap.val();
const side = (a.player===playerId) ? mySide : (mySide==="blue"?"red":"blue");
let x=a.x, y=a.y;
// Enforce pocket clamp on server side too (units only)
if(a.card && a.card.type!=="spell"){
  const lane = laneFromX(x);
  if(side==="blue"){
    if(y<canvas.height/2 && !(lane==="left"?pocketBlue.left:pocketBlue.right)) y=canvas.height/2;
  } else {
    if(y>canvas.height/2 && !(lane==="left"?pocketRed.left:pocketRed.right)) y=canvas.height/2;
  }
}
if(a.card && a.card.type==="spell"){
  castSpell(a.card, side, x, y, a.player);
}else{
  spawnUnit(a.card, side, x, y, a.player);
}
});
}
function attachClientStateListener(){
stateRef.on("value", snap=>{
const st=snap.val();
if(!st) return;
towers = (st.towers||[]).map(t=>({...t}));
units  = (st.units ||[]).map(u=>({...u}));
});
}

/* Names from room */
async function loadRoomNames(){
const playersSnap = await roomRef.child("players").once("value");
let blueId=null, redId=null;
playersSnap.forEach(ch=>{
const v=ch.val(); if(!v) return;
if(v.side==="blue") blueId=ch.key;
if(v.side==="red")  redId=ch.key;
});
const [bNameSnap, rNameSnap] = await Promise.all([
db.ref("players/"+blueId+"/name").once("value"),
db.ref("players/"+redId+"/name").once("value")
]);
nameBlue = bNameSnap.val() || "Blue";
nameRed  = rNameSnap.val() || "Red";
}

/* Room auto-cleanup helpers */
let inactiveCleanupTimer=null, endedCleanupTimer=null;
function setupRoomAutoCleanup(){
roomRef.child("state").on("value", s=>{
if(s.val()==="ended"){
if(endedCleanupTimer) clearTimeout(endedCleanupTimer);
endedCleanupTimer = setTimeout(()=>{ roomRef.remove(); }, 15000);
}
});
roomPlayersRef.on("value", s=>{
let anyConnected=false;
s.forEach(p=>{ const v=p.val(); if(v && v.connected) anyConnected=true; });
if(!anyConnected){
if(inactiveCleanupTimer) clearTimeout(inactiveCleanupTimer);
inactiveCleanupTimer = setTimeout(()=>{ roomRef.remove(); }, 8000);
}else{
if(inactiveCleanupTimer){ clearTimeout(inactiveCleanupTimer); inactiveCleanupTimer=null; }
}
});
}

/* NEW: Emotes */
function setupEmotes(){
  const tray=document.getElementById("emoteTray");
  tray.querySelectorAll(".emote-btn").forEach(btn=>{
    btn.onclick=()=>{
      emoteRef.push({from:playerId, emote:btn.dataset.emote, t:Date.now()});
    };
  });
  emoteRef.on("child_added", snap=>{
    const v=snap.val()||{};
    const em=v.emote||"üòÄ";
    const kBlue = towers.find(t=>t.side==="blue"&&t.king);
    const kRed  = towers.find(t=>t.side==="red" &&t.king);
    if(kBlue) showEmoteBubble(kBlue.x,kBlue.y,em);
    if(kRed)  showEmoteBubble(kRed.x, kRed.y, em);
  });
}
function showEmoteBubble(x,y,em){
  const r=canvas.getBoundingClientRect();
  const el=document.createElement("div");
  el.className="emote-bubble"; el.textContent=em;
  el.style.left=(r.left+x)+"px";
  el.style.top =(r.top +y)+"px";
  document.body.appendChild(el);
  setTimeout(()=>el.remove(),1300);
}

/* Main draw loop */
function drawLoop(ts){
drawArena();

towers.forEach(t=> drawTower(t));
const kBlue = towers.find(t=>t.side==="blue" && t.king);
const kRed  = towers.find(t=>t.side==="red"  && t.king);
if(kBlue) drawTowerName(kBlue, nameBlue);
if(kRed)  drawTowerName(kRed,  nameRed);

if(isHost && !gameOver){
updateTowersAI();
updateUnits();
updateProjectiles();
updatePocketFlags(); // NEW

for(const t of towers){
if(t.hp<=0 && t.king){
const winner = (t.side==="blue") ? "Red" : "Blue";
endGame(winner);
break;
}
}

if(ts - lastPublishTime >= PUBLISH_MS){
lastPublishTime = ts;
stateRef.set({
towers: towers.map(t=>({x:t.x,y:t.y,hp:t.hp,side:t.side,king:!!t.king})),
units:  units.map(u=>({x:u.x,y:u.y,hp:u.hp,maxHp:u.maxHp,side:u.side,name:u.name,level:u.level||1}))
});
}

/* NEW: timer + overtime on host */
if(timerRunning){
  const left = twoMinutes - (Date.now()-matchStartTs);
  if(left<=0){ timerRunning=false; tieBreakOrOvertime(); }
}
}

projectiles.forEach(p=>{ ctx.fillStyle="#ffd86b"; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); });
units.forEach(drawUnit);

/* NEW: timer UI update (clients too) */
updateTimerUI();

if(placementCircle && selectedCard){
ctx.beginPath(); ctx.arc(placementCircle.x, placementCircle.y, 24, 0, Math.PI*2);
ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.stroke();
}

if(!gameOver) requestAnimationFrame(drawLoop);
}

function startBattle(){
searching=false; db.ref("queue/"+playerId).remove();
if(pairInterval){ clearInterval(pairInterval); pairInterval=null; }

/* Show battle-only UI */
document.getElementById("menuScreen").style.display="none";
document.getElementById("battleScreen").style.display="block";
document.getElementById("cardBar").style.display="flex";
document.getElementById("elixirBar").style.display="flex";
/* NEW: show emotes + timer */
document.getElementById("emoteTray").style.display="flex";
document.getElementById("matchTimer").style.display="block";
document.getElementById("overtimeBanner").style.display="none";

document.getElementById("statusText").innerText="In Battle (waiting for opponent‚Ä¶)";

roomRef = db.ref("rooms/"+roomId);
actionsRef = roomRef.child("actions");
stateRef   = roomRef.child("authoritativeState");
roomPlayersRef = roomRef.child("players");
/* NEW: emotes & meta */
emoteRef = roomRef.child("emotes");

roomRef.child("host").transaction(v => v || playerId);

roomRef.child("host").on("value", snap=>{
hostId = snap.val();
isHost = (hostId === playerId);
if(isHost){
if(stateRef) stateRef.off();
attachHostListeners();
}else{
if(actionsRef) actionsRef.off();
attachClientStateListener();
}
});

roomRef.child("players/"+playerId).update({connected:true, side:mySide, name:playerName});
roomRef.child("players/"+playerId).onDisconnect().update({connected:false, lastSeen: firebase.database.ServerValue.TIMESTAMP});

/* NEW: meta start time setup + listeners for clients */
if(isHost){
  matchStartTs = Date.now();
  roomRef.child("meta").update({ startAt: matchStartTs, overtime: false });
  timerRunning = true; twoX=false;
} else {
  roomRef.child("meta/startAt").once("value").then(s=>{
    matchStartTs = s.val() || Date.now();
    timerRunning = true; twoX=false;
  });
}
roomRef.child("meta/overtime").on("value", s=>{
  const v = !!s.val();
  if(v){
    // speed up elixir for everyone
    elixirRegenRate = Math.max(300, Math.floor(elixirRegenRate/2));
    const banner=document.getElementById("overtimeBanner");
    banner.style.display="block";
    setTimeout(()=>{ banner.style.display="none"; },1800);
  }
});

roomPlayersRef.once("value").then(s=>{
let connected=0;
s.forEach(p=>{ if(p.val() && p.val().connected) connected++; });
battleReady = (connected>=2);
document.getElementById("statusText").innerText = battleReady ? "In Battle" : "In Battle (waiting for opponent‚Ä¶)";
});

roomPlayersRef.on("value", s=>{
let connected=0, hostConnected=false;
s.forEach(p=>{
const v=p.val(); if(!v) return;
if(v.connected) connected++;
if(p.key===hostId) hostConnected=!!v.connected;
});
battleReady = (connected>=2);
document.getElementById("statusText").innerText = battleReady ? "In Battle" : "In Battle (waiting for opponent‚Ä¶)";
if(!hostConnected && battleReady && hostId!==playerId){
roomRef.child("host").transaction(v => v || playerId);
}
});

loadRoomNames();
preloadLevelsForRoom(); // load per-player levels for the match

elixir=5; lastElixirTime=Date.now(); initElixirBar();

towers=[
// Blue (reduced dmg)
{x:200,y:560,hp:600,side:"blue",king:false, range:200, dmg:16, cdMax:60},
{x:600,y:560,hp:600,side:"blue",king:false, range:200, dmg:16, cdMax:60},
{x:400,y:640,hp:1000,side:"blue",king:true,  range:250, dmg:26, cdMax:60},
// Red
{x:200,y:140,hp:600,side:"red",king:false, range:200, dmg:16, cdMax:60},
{x:600,y:140,hp:600,side:"red",king:false, range:200, dmg:16, cdMax:60},
{x:400,y:60, hp:1000,side:"red",king:true,  range:250, dmg:26, cdMax:60}
];
units=[]; projectiles=[]; gameOver=false; selectedCard=null; placementCircle=null; battleReady=false;
pendingActionKeys.clear();

/* NEW: pockets reset */
pocketBlue={left:false,right:false};
pocketRed ={left:false,right:false};

/* NEW: build hand from deck */
playerRef.child("ownedCards").once("value").then(ownedSnap=>{
  const owned = ownedSnap.val()||{};
  playerRef.child("deck").once("value").then(deckSnap=>{
    const d = deckSnap.val() || ensureInitialDeck(owned);
    handQueue = buildInitialHandQueue(d, owned);
    renderHand(owned);
  });
});
/* keep live update of owned (for UI) */
playerRef.child("ownedCards").on("value", s=>{
if(document.getElementById("battleScreen").style.display==="block"){
  renderHand(s.val()||{});
}
});

setupRoomAutoCleanup();
setupEmotes();

/* result listener (clients show only, host writes) */
roomRef.child("winner").on("value", snap=>{
const w=snap.val(); if(!w || gameOver) return;
const iWon = (w==="Blue" && mySide==="blue") || (w==="Red" && mySide==="red");
gameOver=true;
document.getElementById("resultText").innerText = iWon ? "üèÜ Victory!" : "‚ùå Defeat";
document.getElementById("rewardText").innerText = iWon ? "+100 Coins, +5 Trophies" : "Better luck next time!";
document.getElementById("resultScreen").style.display="block";
});

/* start render loop */
requestAnimationFrame(drawLoop);
}

function returnToMenu(){
document.getElementById("resultScreen").style.display="none";
document.getElementById("battleScreen").style.display="none";
document.getElementById("menuScreen").style.display="block";
document.getElementById("cardBar").style.display="none";
document.getElementById("elixirBar").style.display="none";
/* NEW: hide emotes & timer when not in battle */
document.getElementById("emoteTray").style.display="none";
document.getElementById("matchTimer").style.display="none";
document.getElementById("overtimeBanner").style.display="none";

document.getElementById("statusText").innerText="Idle";

if(actionsRef) actionsRef.off();
if(stateRef)   stateRef.off();
if(roomPlayersRef) roomPlayersRef.off();
if(roomRef) roomRef.child("host").off();
if(emoteRef) emoteRef.off();

leaveRoomAndMaybeDelete();

placementCircle=null; selectedCard=null; gameOver=false;
roomId=null; mySide=null; searching=false; battleReady=false;
queueAdded=false; isHost=false; hostId=null;

playerRef.child("ownedCards").off();
}

/************ Leaderboard ************/
function renderLeaderboard(rows){
const container = document.getElementById('leaderboardRows');
if(!container) return;
container.innerHTML = '';
rows.forEach((r, idx)=>{
const div = document.createElement('div');
div.className = 'lb-row';
div.innerHTML = `
         <div class="lb-rank">${idx+1}</div>
         <div class="lb-name">${r.name || 'Anon'}</div>
         <div class="lb-trophies">üèÜ ${r.trophies || 0}</div>
       `;
container.appendChild(div);
});
}
function subscribeLeaderboard(){
db.ref('players').orderByChild('trophies').limitToLast(20).on('value', snap=>{
const arr=[];
snap.forEach(ch=>{
const v = ch.val() || {};
arr.push({ name: v.name || 'Anon', trophies: v.trophies || 0 });
});
arr.sort((a,b)=> b.trophies - a.trophies);
renderLeaderboard(arr);
});
}
subscribeLeaderboard();
</script>

<!-- CHANGELOG SCRIPT -->
<script>
(function(){
function showChangelog(){
var ov=document.getElementById('changelogOverlay');
if(ov){ ov.style.display='flex'; }
}
function hideChangelog(){
var ov=document.getElementById('changelogOverlay');
if(ov){ ov.style.display='none'; }
}
document.addEventListener('DOMContentLoaded', function(){
var btn=document.getElementById('changelogClose');
var ov=document.getElementById('changelogOverlay');
if(btn){ btn.addEventListener('click', hideChangelog); }
if(ov){ ov.addEventListener('click', function(e){ if(e.target===ov) hideChangelog(); }); }
showChangelog();
});
})();
</script>

<!-- OPTIONAL: randomize dancer delays (menu only) -->
<script>
(function(){
const dancers = document.querySelectorAll('#dancerStage .dancer');
if(!dancers.length) return;
dancers.forEach((d,i)=>{
const jitter = (Math.random()*0.25).toFixed(2);
d.style.setProperty('--delay', (i*0.12 + parseFloat(jitter)) + 's');
});
})();
</script>

<!-- STARTING SPLASH logic + BGM start -->
<script>
(function(){
const overlay = document.getElementById('startOverlay');
const bgm = document.getElementById('bgm');

function tryPlayBgm(){
if(!bgm) return;
bgm.play().catch(function(){
const kick = function(){
bgm.play().catch(()=>{});
document.removeEventListener('click', kick);
document.removeEventListener('keydown', kick);
document.removeEventListener('touchstart', kick);
};
document.addEventListener('click', kick, {once:true});
document.addEventListener('keydown', kick, {once:true});
document.addEventListener('touchstart', kick, {once:true});
});
}

if(overlay){
const hide = function(e){
if(e){ e.preventDefault(); e.stopPropagation(); }
overlay.style.transition = 'opacity 300ms ease';
overlay.style.opacity = '0';
setTimeout(()=>{ overlay.style.display='none'; }, 320);
overlay.removeEventListener('click', hide);
tryPlayBgm(); // start music after user gesture
};
overlay.addEventListener('click', hide);
}
})();
</script>

<!-- NEW: Top Bar Fix (unchanged but kept) -->
<script>
/* === Top Bar Fix (pin to top + move ads below it) === */
(function(){
  function applyFix(){
    var topBar = document.querySelector('.top-bar');
    if(!topBar) return;

    var css = `
      :root{ --top-h: ${Math.max(56, Math.round(document.querySelector('.top-bar').getBoundingClientRect().height||56))}px; }
      .top-bar{
        position: fixed !important;
        top: 0; left: 0; right: 0;
        height: var(--top-h);
        z-index: 1000;
      }
      .screen{
        height: calc(100vh - var(--top-h)) !important;
        margin-top: var(--top-h) !important;
        position: relative;
      }
    `;
    var style = document.getElementById('topbar-fix-style');
    if(!style){
      style = document.createElement('style');
      style.id = 'topbar-fix-style';
      document.head.appendChild(style);
    }
    style.textContent = css;

    var ads = Array.from(document.querySelectorAll('ins.adsbygoogle'));
    ads.forEach(function(ad){
      if(!ad || !ad.parentNode) return;
      var isBefore = !!(ad.compareDocumentPosition(topBar) & Node.DOCUMENT_POSITION_FOLLOWING);
      if(isBefore){
        topBar.insertAdjacentElement('afterend', ad);
        try{
          if(!ad.getAttribute('data-adsbygoogle-status')){
            (window.adsbygoogle = window.adsbygoogle || []).push({});
          }
        }catch(e){}
      }
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyFix);
  } else {
    applyFix();
  }

  window.addEventListener('load', function(){
    var topBar = document.querySelector('.top-bar');
    if(!topBar) return;
    var style = document.getElementById('topbar-fix-style');
    if(!style) return;
    var h = Math.max(56, Math.round(topBar.getBoundingClientRect().height||56));
    style.textContent = style.textContent.replace(/--top-h:\s*[^;]+;/, '--top-h: '+h+'px;');
  });
})();
</script>

</body>
</html>
"""
# Quick fix: a typo slipped in drawArena (I used 'x='). Replace that token.
html = html.replace("const bridges=[ {x=BRIDGE_CENTERS[0]-BRIDGE_W/2, y:RIVER_Y-6}, {x:BRIDGE_CENTERS[1]-BRIDGE_W/2, y:RIVER_Y-6} ];",
                    "const bridges=[ {x:BRIDGE_CENTERS[0]-BRIDGE_W/2, y:RIVER_Y-6}, {x:BRIDGE_CENTERS[1]-BRIDGE_W/2, y:RIVER_Y-6} ];")

out_path = "/mnt/data/flash-royale-avatars.html"
with open(out_path, "w", encoding="utf-8") as f:
    f.write(html)

out_path
