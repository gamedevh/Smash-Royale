<html lang="en"><head>
<meta charset="UTF-8">
<title>Flash Royale (Pocketing + Timer + Swarm)</title>
<!-- Google tag (kept) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-61B7P6WEL0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-61B7P6WEL0');</script>
<style>

:root{
  --bg-dark: #0b0f1c;
  --bg-mid:  #101827;
  --accent:  #7c3aed;
  --accent2: #06b6d4;
  --gold:    #ffcc00;
  --hud-bg:  rgba(10,15,30,0.70);
  --hud-border:#1e3d59;
}

body{ margin:0; font-family:Arial, sans-serif; color:#fff; user-select:none; overflow:hidden; background:var(--bg-dark); }
.top-bar{display:flex;justify-content:space-between;align-items:center;padding:10px 20px;background:var(--hud-bg);border-bottom:3px solid var(--hud-border);font-size:14px;position:relative;z-index:3;}
.currency{display:flex;gap:15px;}
.currency div{background:#2d3e50;padding:5px 12px;border-radius:8px;display:flex;align-items:center;gap:6px;}
#onlineCount{margin-left:12px;font-weight:bold;}
#matchTimer{position:fixed;top:66px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.45);border:2px solid #fff;border-radius:10px;padding:6px 10px;z-index:6;font-weight:700;letter-spacing:.5px;}
#banner{position:fixed;top:110px;left:50%;transform:translateX(-50%);background:linear-gradient(90deg,var(--accent),var(--accent2));border:2px solid #fff;border-radius:12px;padding:8px 16px;z-index:6;display:none;font-weight:800;box-shadow:0 10px 30px rgba(0,0,0,.35);}
.screen{display:none;height:calc(100vh - 56px);position:relative;}
#menuScreen{display:block;text-align:center;padding-bottom:120px;overflow:auto;}
#battleScreen{display:none;text-align:center;position:relative;}
.battle-btn{background:var(--gold);padding:20px 60px;border-radius:20px;font-size:32px;color:#000;cursor:pointer;margin-top:20px;border:3px solid #fff;box-shadow:0 0 25px rgba(255,204,0,.9);}
.cancel-btn{background:#ff4444;padding:15px 40px;border-radius:15px;font-size:24px;color:#fff;cursor:pointer;margin-top:20px;border:3px solid #fff;box-shadow:0 0 20px rgba(255,0,0,.7);display:none;}
.deck,.shop{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin:20px auto;max-width:540px;position:relative;z-index:2;}
.card{position:relative;border-radius:12px;overflow:hidden;text-align:center;font-size:12px;cursor:pointer;background:linear-gradient(to bottom,#2f3345,#151826);border:3px solid #889;box-shadow:0 3px 8px rgba(0,0,0,.6);padding:8px;}
.card img{width:70%;margin:5px auto;display:block;}
.card.selected{border:3px solid cyan;box-shadow:0 0 15px cyan;}
.card.cooldown{opacity:.45;pointer-events:none;filter:grayscale(.5);}
.elixir-cost{position:absolute;top:5px;left:5px;background:#9c27b0;border-radius:50%;width:28px;height:28px;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:bold;border:2px solid #fff;}
.price-tag{position:absolute;bottom:6px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.6);padding:2px 6px;border-radius:6px;font-size:12px;}
.shop .buy-btn{margin-top:6px;padding:6px 10px;border-radius:8px;border:2px solid #fff;background:#28a745;color:#fff;cursor:pointer;}
.shop .buy-btn[disabled]{opacity:.6;cursor:not-allowed;}
.shop .owned{margin-top:6px;padding:6px 10px;border-radius:8px;border:2px solid #888;background:#444;color:#aaa;}
#deckSummary{max-width:540px;margin:0 auto;text-align:left;}
#deckSummary .slots{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px;}
.slotChip{padding:4px 8px;border-radius:10px;border:1px solid #94a3b8;background:#0b1220;font-size:12px;}
.deck-toggle{margin-top:6px;padding:6px 10px;border-radius:8px;border:2px solid #fff;background:#0ea5e9;color:#fff;cursor:pointer;}
.deck-toggle.remove{background:#ef4444;}
.level-badge{position:absolute;top:5px;right:5px;background:#0ea5e9;border:2px solid #fff;border-radius:12px;padding:2px 6px;font-weight:700;font-size:12px;}
.upgrade-btn{margin-top:8px;padding:6px 10px;border-radius:8px;border:2px solid #fff;background:#2563eb;color:#fff;cursor:pointer;}
.upgrade-btn[disabled]{opacity:.6;cursor:not-allowed;}
#battleCanvas{position:relative;background:transparent;border:3px solid #fff;margin:20px auto 0;display:block;z-index:1;}
#cardBar{position:fixed;bottom:100px;left:50%;transform:translateX(-50%);display:none;gap:10px;z-index:5;}
#elixirBar{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);width:500px;height:24px;border:2px solid #fff;border-radius:10px;background:#222;display:none;justify-content:space-between;padding:2px;z-index:5;}
.elixir-segment{flex:1;margin:0 1px;background:#444;border-radius:4px;}
.elixir-filled{background:purple;}
#emoteTray{position:fixed;left:20px;bottom:160px;display:none;gap:8px;z-index:6;}
.emote-btn{font-size:20px;border:2px solid #fff;background:#0b1220;border-radius:10px;padding:6px 8px;cursor:pointer;}
.emote-btn:disabled{opacity:.5;cursor:not-allowed;}
.emote-bubble{position:fixed;font-size:28px;padding:6px 10px;border-radius:14px;background:rgba(0,0,0,.5);border:2px solid #fff;transform:translate(-50%,-100%);pointer-events:none;z-index:7;animation:emotePop 1.3s ease-out forwards;}
@keyframes emotePop{0%{opacity:0;transform:translate(-50%,-80%) scale(.8);}10%{opacity:1;transform:translate(-50%,-100%) scale(1);}70%{opacity:1;transform:translate(-50%,-125%) scale(1);}100%{opacity:0;transform:translate(-50%,-140%) scale(1);}}
#resultScreen{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);color:#fff;text-align:center;font-size:32px;padding-top:200px;z-index:10;}
#resultScreen button{margin-top:30px;padding:15px 40px;font-size:20px;border:none;border-radius:12px;cursor:pointer;background:gold;color:#000;}
.leaderboard{position:fixed;right:20px;top:90px;bottom:20px;width:360px;overflow:auto;text-align:left;background:rgba(17,24,39,.85);border:2px solid #334155;border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.35);z-index:2;}
.leaderboard h3{margin:0;padding:12px 16px;background:#0f172a;border-bottom:2px solid #334155;font-size:18px;}
.lb-row{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid rgba(255,255,255,.07);}
.lb-row:nth-child(odd){background:rgba(255,255,255,.02);}
.lb-rank{width:36px;text-align:center;font-weight:bold;}
.lb-name{flex:1;padding:0 8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
.lb-trophies{min-width:90px;text-align:right;font-weight:bold;}
#manualPanel{position:fixed;left:20px;top:90px;bottom:220px;width:360px;overflow:auto;text-align:left;background:rgba(17,24,39,.85);border:2px solid #334155;border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.35);z-index:2;padding-bottom:10px;}
#manualPanel h3{margin:0;padding:12px 16px;background:#0f172a;border-bottom:2px solid #334155;font-size:18px;}
#manualPanel .section{padding:10px 16px 4px;border-bottom:1px dashed rgba(255,255,255,.08);}
#manualPanel .section:last-child{border-bottom:none;}
#manualPanel ul{margin:6px 0 6px 18px;padding:0;}
#manualPanel li{margin:4px 0;line-height:1.35;}
#manualPanel .kbd{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.2);background:#0b1220;font-size:12px;}
@media (max-width:1100px){#manualPanel{display:none;}}

</style>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
</head>
<body>

<div class="top-bar">
  <div class="currency"><div><img src="https://img.icons8.com/emoji/48/000000/coin-emoji.png" width="18" height="18"> <span id="coinCount">400</span></div></div>
  <div><span id="statusText">Idle</span> <span id="onlineCount">Online: 1</span></div>
</div>
<div id="matchTimer" aria-live="polite">02:00</div>
<div id="banner">2√ó ELIXIR</div>

<!-- MENU -->
<div id="menuScreen" class="screen">
  <h2>üèÜ Flash Royale</h2>
  <p>Name: <b id="playerNameLabel">test</b></p>
  <p>Your trophies: <b id="trophies">0</b></p>
  <button id="battleBtn" class="battle-btn" onclick="findMatch()">BATTLE</button>
  <button id="cancelBtn" class="cancel-btn" onclick="cancelSearch()">Cancel</button>
  <h2>Your Deck</h2>
  <div id="deckSummary"><div><b>Slots:</b> <span id="deckCount">4</span>/8</div><div class="slots" id="deckSlots"><span class="slotChip">Archer</span><span class="slotChip">Dragon</span><span class="slotChip">Golem</span><span class="slotChip">Knight</span></div></div>
  <div class="deck" id="deck"><div class="card">
        <div class="elixir-cost">3</div>
        <div class="level-badge">Lv 1</div>
        <img src="https://img.icons8.com/color/96/knight.png"><b>Knight</b>
        <button class="upgrade-btn" data-name="Knight">Upgrade (100ü™ô)</button>
        <button class="deck-toggle remove" data-name="Knight">Remove from Deck</button>
      </div><div class="card">
        <div class="elixir-cost">3</div>
        <div class="level-badge">Lv 1</div>
        <img src="https://img.icons8.com/color/96/bow.png"><b>Archer</b>
        <button class="upgrade-btn" data-name="Archer">Upgrade (100ü™ô)</button>
        <button class="deck-toggle remove" data-name="Archer">Remove from Deck</button>
      </div><div class="card">
        <div class="elixir-cost">6</div>
        <div class="level-badge">Lv 1</div>
        <img src="https://img.icons8.com/color/96/rock.png"><b>Golem</b>
        <button class="upgrade-btn" data-name="Golem">Upgrade (100ü™ô)</button>
        <button class="deck-toggle remove" data-name="Golem">Remove from Deck</button>
      </div><div class="card">
        <div class="elixir-cost">5</div>
        <div class="level-badge">Lv 1</div>
        <img src="https://img.icons8.com/color/96/dragon.png"><b>Dragon</b>
        <button class="upgrade-btn" data-name="Dragon">Upgrade (100ü™ô)</button>
        <button class="deck-toggle remove" data-name="Dragon">Remove from Deck</button>
      </div></div>
  <h2>Shop</h2><div class="shop" id="shop"><div class="card"><div class="elixir-cost">5</div><img src="https://img.icons8.com/color/96/wizard.png"><b>Wizard</b><div class="price-tag">500 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">2</div><img src="https://img.icons8.com/color/96/goblin.png"><b>Goblin</b><div class="price-tag">200 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/barbarian.png"><b>Barbarian</b><div class="price-tag">400 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">1</div><img src="https://img.icons8.com/color/96/snowflake.png"><b>Ice Spirit</b><div class="price-tag">150 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">7</div><img src="https://img.icons8.com/color/96/giant.png"><b>Giant</b><div class="price-tag">700 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/musket.png"><b>Musketeer</b><div class="price-tag">450 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">5</div><img src="https://img.icons8.com/color/96/prince.png"><b>Prince</b><div class="price-tag">600 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">5</div><img src="https://img.icons8.com/color/96/darth-vader.png"><b>Dark Knight</b><div class="price-tag">600 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/angel.png"><b>Healer</b><div class="price-tag">400 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">3</div><img src="https://img.icons8.com/color/96/bomb.png"><b>Bomber</b><div class="price-tag">300 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">3</div><img src="https://img.icons8.com/color/96/skeleton.png"><b>Skeleton Army</b><div class="price-tag">250 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/valkyrie.png"><b>Valkyrie</b><div class="price-tag">450 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/boar.png"><b>Hog Rider</b><div class="price-tag">500 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">2</div><img src="https://img.icons8.com/color/96/lightning-bolt.png"><b>Electro Spirit</b><div class="price-tag">250 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/baby-dragon.png"><b>Baby Dragon</b><div class="price-tag">500 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">8</div><img src="https://img.icons8.com/color/96/robot.png"><b>Pekka</b><div class="price-tag">800 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/ninja.png"><b>Bandit</b><div class="price-tag">500 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">5</div><img src="https://img.icons8.com/color/96/witch.png"><b>Witch</b><div class="price-tag">500 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">6</div><img src="https://img.icons8.com/color/96/bowling-ball.png"><b>Bowler</b><div class="price-tag">600 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/shotgun.png"><b>Hunter</b><div class="price-tag">500 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">3</div><img src="https://img.icons8.com/color/96/minion.png"><b>Mega Minion</b><div class="price-tag">350 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">4</div><img src="https://img.icons8.com/color/96/fireball.png"><b>Fireball</b><div class="price-tag">450 ü™ô</div>
      <button class="buy-btn">Buy</button></div><div class="card"><div class="elixir-cost">3</div><img src="https://img.icons8.com/color/96/archers-bow.png"><b>Arrows</b><div class="price-tag">350 ü™ô</div>
      <button class="buy-btn">Buy</button></div></div>
  <div class="leaderboard" id="leaderboard"><h3>üåç Global Leaderboard (Trophies)</h3><div id="leaderboardRows"></div></div>
  <aside id="manualPanel" aria-label="Game Manual">
    <h3>üìñ Quick Manual</h3>
    <div class="section"><strong>How to Start</strong><ul>
      <li>Hit <span class="kbd">BATTLE</span> to join the queue. Strict 1v1 rooms.</li>
      <li>If no one‚Äôs ready yet, you‚Äôll see <em>Searching‚Ä¶</em>.</li>
    </ul></div>
    <div class="section"><strong>Placement &amp; Pocketing</strong><ul>
      <li>Units: your half only‚Äîuntil you destroy a lane tower. When a lane tower falls, you unlock <b>pocket</b> placement on that lane of the enemy side.</li>
      <li>Spells: anywhere.</li>
    </ul></div>
    <div class="section"><strong>Elixir &amp; Cards</strong><ul>
      <li>Elixir +1 every 2s (10 max). Overtime: <b>2√ó elixir</b>.</li>
      <li>Battle hand shows 4 of your 8 deck cards; used cards rotate to back.</li>
    </ul></div>
    <div class="section"><strong>Win Rules</strong><ul>
      <li>Destroy the king tower to win.</li>
      <li>At 2:00: if you‚Äôve taken ‚â•1 enemy lane tower while both of your lane towers remain, you win. Else, 2√ó elixir begins.</li>
    </ul></div>
  </aside>
</div>

<!-- BATTLE -->
<div id="battleScreen" class="screen">
  <canvas id="battleCanvas" width="800" height="700"></canvas>
</div>
<div id="cardBar"></div>
<div id="elixirBar"></div>
<div id="emoteTray"><button class="emote-btn" data-emote="üòÄ">üòÄ</button><button class="emote-btn" data-emote="üò°">üò°</button><button class="emote-btn" data-emote="üò≠">üò≠</button><button class="emote-btn" data-emote="üëç">üëç</button></div>
<div id="resultScreen"><h1 id="resultText"></h1><p id="rewardText"></p><button onclick="returnToMenu()">OK</button></div>

<script>
/* ==== Firebase ==== */
const firebaseConfig = {
  apiKey:"AIzaSyA3FUH9RZiQ9IRChNpGqNrgjt2r5AA5RF8",
  authDomain:"flash-royale-a92c0.firebaseapp.com",
  databaseURL:"https://flash-royale-a92c0-default-rtdb.firebaseio.com",
  projectId:"flash-royale-a92c0",
  storageBucket:"flash-royale-a92c0.appspot.com",
  messagingSenderId:"703977930640",
  appId:"1:703977930640:web:a4f70deb5bbe508aec7d15",
  measurementId:"G-61B7P6WEL0"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ==== Name + Presence ==== */
function normalizeForFilter(s){ if(!s) return ""; s=(""+s).toLowerCase(); const map={'0':'o','1':'i','!':'i','3':'e','4':'a','@':'a','$':'s','5':'s','7':'t','8':'b','9':'g'};
  s=s.replace(/[0!134@5$789]/g,ch=>map[ch]||ch); s=s.replace(/[^a-z0-9]/g,""); s=s.replace(/([a-z0-9])\1{1,}/g,"$1$1"); return s; }
const bannedWords=["fuck","shit","bitch","cunt","dick","pussy","ass","asshole","bastard","damn","sucker","gay","nazi","crap","kill"];
function containsBannedWord(name){ const n=normalizeForFilter(name); return bannedWords.some(w=>n.includes(w)); }
function sanitizeNameBasic(s){ return (s||"").replace(/[^a-zA-Z0-9]/g,"").substring(0,6); }
function requestCleanName(){ for(let i=0;i<3;i++){ const raw=prompt("Enter your player name (max 6 letters/numbers):",""); const cleaned=sanitizeNameBasic(raw);
  if(cleaned && !containsBannedWord(cleaned)) return cleaned; alert("That name isn't allowed. Please choose another."); } return "Anon"; }

let playerId=localStorage.getItem("playerId"); if(!playerId){ playerId="player-"+Math.floor(Math.random()*10000); localStorage.setItem("playerId",playerId); }
let playerName=localStorage.getItem("playerName");
if(!playerName){ playerName=requestCleanName(); localStorage.setItem("playerName",playerName); }
else if(containsBannedWord(playerName) || !/^[a-zA-Z0-9]{1,6}$/.test(playerName)){ playerName=requestCleanName(); localStorage.setItem("playerName",playerName); }
document.getElementById("playerNameLabel").innerText=playerName;

const playerRef=db.ref("players/"+playerId);
playerRef.once("value").then(snap=>{
  if(!snap.exists()){ playerRef.set({name:playerName,online:true,disconnected:false,coins:400,trophies:0,ownedCards:{"Knight":true,"Archer":true,"Golem":true,"Dragon":true} }); }
  else{ const p=snap.val()||{}; const up={name:playerName,online:true,disconnected:false}; if(p.coins==null) up.coins=400; playerRef.update(up); }
  const starters={"Knight":1,"Archer":1,"Golem":1,"Dragon":1}; playerRef.child("levels").transaction(lv=>{ lv=lv||{}; for(const k in starters) if(!lv[k]) lv[k]=1; return lv; });
});
playerRef.on("value", s=>{ const p=s.val()||{}; document.getElementById("coinCount").innerText=p.coins||0; document.getElementById("trophies").innerText=p.trophies||0; });
db.ref("players").on("value", snap=>{ let on=0; snap.forEach(c=>{ if(c.val() && c.val().online) on++; }); document.getElementById("onlineCount").innerText="Online: "+on; });
playerRef.onDisconnect().update({online:false,disconnected:true});

/* ==== Cards, Deck (8), Rotation(4) ==== */
const allCards=[
  {name:"Knight",hp:200,maxHp:200,dmg:20,range:25,cost:3,speed:2,img:"https://img.icons8.com/color/96/knight.png", price:0},
  {name:"Archer",hp:120,maxHp:120,dmg:15,range:120,cost:3,speed:2,img:"https://img.icons8.com/color/96/bow.png", price:0},
  {name:"Golem",hp:400,maxHp:400,dmg:30,range:25,cost:6,speed:1,img:"https://img.icons8.com/color/96/rock.png", price:0},
  {name:"Dragon",hp:150,maxHp:150,dmg:40,range:100,cost:5,speed:3,img:"https://img.icons8.com/color/96/dragon.png", price:0},
  {name:"Wizard",hp:160,maxHp:160,dmg:35,range:150,cost:5,speed:2,img:"https://img.icons8.com/color/96/wizard.png", price:500},
  {name:"Goblin",hp:90,maxHp:90,dmg:12,range:25,cost:2,speed:4,img:"https://img.icons8.com/color/96/goblin.png", price:200},
  {name:"Barbarian",hp:220,maxHp:220,dmg:25,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/barbarian.png", price:400},
  {name:"Ice Spirit",hp:80,maxHp:80,dmg:10,range:20,cost:1,speed:5,img:"https://img.icons8.com/color/96/snowflake.png", price:150},
  {name:"Giant",hp:600,maxHp:600,dmg:45,range:25,cost:7,speed:1,img:"https://img.icons8.com/color/96/giant.png", price:700},
  {name:"Musketeer",hp:140,maxHp:140,dmg:30,range:200,cost:4,speed:2,img:"https://img.icons8.com/color/96/musket.png", price:450},
  {name:"Prince",hp:280,maxHp:280,dmg:50,range:25,cost:5,speed:3,img:"https://img.icons8.com/color/96/prince.png", price:600},
  {name:"Dark Knight",hp:260,maxHp:260,dmg:35,range:30,cost:5,speed:3,img:"https://img.icons8.com/color/96/darth-vader.png", price:600},
  {name:"Healer",hp:150,maxHp:150,dmg:0,range:60,cost:4,speed:2,img:"https://img.icons8.com/color/96/angel.png", price:400},
  {name:"Bomber",hp:110,maxHp:110,dmg:45,range:60,cost:3,speed:2,img:"https://img.icons8.com/color/96/bomb.png", price:300},
  {name:"Skeleton Army",hp:35,maxHp:35,dmg:7,range:20,cost:3,speed:2.4,img:"https://img.icons8.com/color/96/skeleton.png", price:250},
  {name:"Valkyrie",hp:260,maxHp:260,dmg:40,range:25,cost:4,speed:2,img:"https://img.icons8.com/color/96/valkyrie.png", price:450},
  {name:"Hog Rider",hp:280,maxHp:280,dmg:55,range:25,cost:4,speed:4,img:"https://img.icons8.com/color/96/boar.png", price:500},
  {name:"Electro Spirit",hp:100,maxHp:100,dmg:20,range:60,cost:2,speed:4,img:"https://img.icons8.com/color/96/lightning-bolt.png", price:250},
  {name:"Baby Dragon",hp:180,maxHp:180,dmg:35,range:80,cost:4,speed:3,img:"https://img.icons8.com/color/96/baby-dragon.png", price:500},
  {name:"Pekka",hp:700,maxHp:700,dmg:80,range:25,cost:8,speed:1,img:"https://img.icons8.com/color/96/robot.png", price:800},
  {name:"Bandit",hp:200,maxHp:200,dmg:40,range:25,cost:4,speed:5,img:"https://img.icons8.com/color/96/ninja.png", price:500},
  {name:"Witch",hp:160,maxHp:160,dmg:25,range:180,cost:5,speed:2,img:"https://img.icons8.com/color/96/witch.png", price:500},
  {name:"Bowler",hp:300,maxHp:300,dmg:35,range:150,cost:6,speed:2,img:"https://img.icons8.com/color/96/bowling-ball.png", price:600},
  {name:"Hunter",hp:200,maxHp:200,dmg:50,range:100,cost:4,speed:3,img:"https://img.icons8.com/color/96/shotgun.png", price:500},
  {name:"Mega Minion",hp:140,maxHp:140,dmg:30,range:50,cost:3,speed:3,img:"https://img.icons8.com/color/96/minion.png", price:350},
  {name:"Fireball",type:"spell",dmg:180,radius:70,cost:4,img:"https://img.icons8.com/color/96/fireball.png", price:450},
  {name:"Arrows",type:"spell",dmg:90,radius:120,cost:3,img:"https://img.icons8.com/color/96/archers-bow.png", price:350}
];
const MAX_LEVEL=15;
function upgradeCostFor(level){ level=Math.max(1,Math.min(MAX_LEVEL-1,level)); return 100*level; }
function levelMultiplier(level){ return 1 + 0.08*(Math.max(1,Math.min(MAX_LEVEL,level))-1); }
let playerLevels={}; let playerOwned={}; let playerDeck=[];
function ensureInitialDeck(owned){ const names=Object.keys(owned||{}); const initial=[]; for(let i=0;i<names.length && initial.length<8;i++) initial.push(names[i]); return initial; }
playerRef.child("levels").on("value", s=>{ playerLevels=s.val()||{}; playerRef.once("value").then(snap=>{ const p=snap.val()||{}; renderDeck(p.ownedCards||{}, p.coins||0); }); });

function renderDeck(owned, coins){
  playerOwned = owned||{};
  const deckEl=document.getElementById("deck"); deckEl.innerHTML="";
  const deckSlots=document.getElementById("deckSlots"); deckSlots.innerHTML="";
  const deckCountEl=document.getElementById("deckCount");
  playerRef.child("deck").once("value").then(s=>{
    playerDeck = s.val()||ensureInitialDeck(playerOwned);
    if(playerDeck.length>8) playerDeck=playerDeck.slice(0,8);
    deckCountEl.innerText = playerDeck.length;
    playerDeck.forEach(nm=>{ const chip=document.createElement("span"); chip.className="slotChip"; chip.textContent=nm; deckSlots.appendChild(chip); });
    allCards.forEach(c=>{
      if(!playerOwned[c.name]) return;
      const lvl=Math.max(1,Math.min(MAX_LEVEL,(playerLevels && playerLevels[c.name])||1));
      const canLevel=lvl<MAX_LEVEL; const cost=canLevel?upgradeCostFor(lvl):0;
      const d=document.createElement("div"); d.className="card";
      const inDeck=playerDeck.includes(c.name);
      d.innerHTML=`
        <div class="elixir-cost">${c.cost}</div>
        <div class="level-badge">Lv ${lvl}</div>
        <img src="${c.img}"><b>${c.name}</b>
        ${canLevel?`<button class="upgrade-btn" data-name="${c.name}" ${(coins>=cost)?'':'disabled'}>Upgrade (${cost}ü™ô)</button>`:`<div class="owned">Max Level</div>`}
        <button class="deck-toggle ${inDeck?'remove':''}" data-name="${c.name}">${inDeck?'Remove from Deck':'Add to Deck'}</button>
      `;
      if(canLevel){ const btn=d.querySelector(".upgrade-btn"); btn.onclick=()=>{ btn.disabled=true;
        const current=Math.max(1,Math.min(MAX_LEVEL,(playerLevels && playerLevels[c.name])||1)); if(current>=MAX_LEVEL) return;
        const costNow=upgradeCostFor(current);
        playerRef.child("coins").transaction(v=>{ v=v||0; if(v<costNow) return; return v-costNow; },(err,comm)=>{ if(err||!comm){ btn.disabled=false; return alert("Not enough coins or network error."); }
          playerRef.child("levels/"+c.name).transaction(lv=>{ lv=Math.max(1,Math.min(MAX_LEVEL,lv||1)); if(lv>=MAX_LEVEL) return lv; return lv+1; });
        });
      }; }
      const tog=d.querySelector(".deck-toggle"); tog.onclick=()=>{ const nm=c.name; const inD=playerDeck.includes(nm);
        if(inD) playerDeck = playerDeck.filter(x=>x!==nm);
        else{ if(playerDeck.length>=8) return alert("Your deck can only hold 8 cards."); playerDeck.push(nm); }
        playerRef.child("deck").set(playerDeck).then(()=>renderDeck(playerOwned, coins));
      };
      deckEl.appendChild(d);
    });
  });
}

function renderShop(owned, coins){
  const shop=document.getElementById("shop"); shop.innerHTML="";
  allCards.forEach(c=>{
    if(c.price<=0) return;
    const ownedFlag=!!owned[c.name];
    const el=document.createElement("div"); el.className="card";
    el.innerHTML=`<div class="elixir-cost">${c.cost}</div><img src="${c.img}"><b>${c.name}</b><div class="price-tag">${c.price} ü™ô</div>
      <button class="${ownedFlag?'owned':'buy-btn'}" ${ownedFlag?'disabled':''}>${ownedFlag?'Owned':'Buy'}</button>`;
    if(!ownedFlag){ const btn=el.querySelector(".buy-btn"); btn.onclick=()=>{ btn.disabled=true; btn.textContent="Buying...";
      playerRef.child("coins").transaction(v=>{ v=v||0; if(v<c.price) return; return v-c.price; },(err,comm)=>{ if(err||!comm){ btn.disabled=false; btn.textContent="Buy"; return alert("Not enough coins or network error."); }
        playerRef.child("ownedCards/"+c.name).set(true);
        playerRef.child("levels/"+c.name).transaction(lv=>lv||1);
        playerRef.child("deck").transaction(d=>{ d=d||[]; if(d.length<8) d.push(c.name); return d; });
      });
    }; }
    shop.appendChild(el);
  });
}
playerRef.on("value", s=>{ const p=s.val()||{}; const owned=p.ownedCards||{}; renderDeck(owned, p.coins||0); renderShop(owned, p.coins||0); });

/* ==== Matchmaking ==== */
let roomId=null,mySide=null,searching=false,battleReady=false,isHost=false,hostId=null;
let roomRef=null,actionsRef=null,stateRef=null,roomPlayersRef=null,queueAdded=false,pairInterval=null;
let emoteRef=null;
function findMatch(){
  document.getElementById("statusText").innerText="Searching...";
  document.getElementById("battleBtn").style.display="none";
  document.getElementById("cancelBtn").style.display="inline-block";
  searching=true;
  const myQueueRef=db.ref("queue/"+playerId);
  if(!queueAdded){ myQueueRef.set({name:playerName,ts:firebase.database.ServerValue.TIMESTAMP,searching:true}); myQueueRef.onDisconnect().remove(); queueAdded=true; }
  attemptPair(); if(pairInterval) clearInterval(pairInterval);
  pairInterval=setInterval(()=>{ if(searching && !roomId) attemptPair(); },1500);
  db.ref("rooms").on("child_added", snap=>{ if(!searching||roomId) return; const r=snap.val(); if(r && r.players && r.players[playerId]){ roomId=snap.key; mySide=r.players[playerId].side||"red"; startBattle(); } });
}
function attemptPair(){
  db.ref("queue").once("value").then(snap=>{
    if(!searching||roomId) return; const q=snap.val()||{}; let cand=null,best=Infinity;
    Object.keys(q).forEach(k=>{ if(k===playerId) return; const it=q[k]; if(!it||it.claimed) return; const ts=typeof it.ts==='number'?it.ts:Date.now(); if(ts<best){ best=ts; cand=k; } });
    if(!cand) return;
    db.ref("queue/"+cand+"/claimed").transaction(val=>{ if(val) return; return playerId; }, async (err,comm,s2)=>{
      if(err||!comm||s2.val()!==playerId) return;
      const oppNameSnap=await db.ref("players/"+cand+"/name").once("value"); const oppName=oppNameSnap.val()||"Opponent";
      roomId="room-"+Date.now()+"-"+Math.floor(Math.random()*1000); mySide="blue";
      const roomData={createdAt:firebase.database.ServerValue.TIMESTAMP,state:"active",host:playerId,
        players:{[playerId]:{connected:true,side:"blue",name:playerName},[cand]:{connected:true,side:"red",name:oppName}} };
      db.ref("rooms/"+roomId).set(roomData).then(()=>{ db.ref("queue/"+cand).remove(); db.ref("queue/"+playerId).remove(); startBattle(); });
    });
  });
}
function cancelSearch(){ searching=false; if(pairInterval){clearInterval(pairInterval);pairInterval=null;} db.ref("queue/"+playerId).remove(); queueAdded=false;
  document.getElementById("statusText").innerText="Idle"; document.getElementById("battleBtn").style.display="inline-block"; document.getElementById("cancelBtn").style.display="none"; }
function tryRejoinRoom(){ db.ref("rooms").once("value").then(s=>{ s.forEach(r=>{ const val=r.val(); if(val && val.state==="active" && val.players && val.players[playerId]){ roomId=r.key; mySide=val.players[playerId].side||"red"; startBattle(); } }); }); }
playerRef.once("value").then(s=>{ const p=s.val()||{}; if(p.disconnected){ tryRejoinRoom(); playerRef.update({disconnected:false,online:true}); } });

/* ==== Battle Core ==== */
const canvas=document.getElementById("battleCanvas"); const ctx=canvas.getContext("2d");
const RIVER_H=40; const BRIDGE_W=140; const RIVER_Y=canvas.height/2 - RIVER_H/2; const BRIDGE_CENTERS=[220,580];
let towers=[],units=[],selectedCard=null; let placementCircle=null,lastMouse={x:canvas.width/2,y:canvas.height*0.75}; const cardCooldowns={}; let projectiles=[]; let gameOver=false;
let nameBlue="Blue",nameRed="Red"; let pendingActionKeys=new Set(); let lastPublishTime=0,PUBLISH_MS=100; let roomLevelsCache={};
let elixir=0,maxElixir=10, elixirRegenRate=2000, lastElixirTime=Date.now();
let handQueue=[]; let emoteCooldown=0;
let pocketBlue={left:false,right:false}; let pocketRed ={left:false,right:false};
let matchStartTs=0; let twoMinutes=120000; let timerRunning=false; let twoX=false;

function initElixirBar(){ const bar=document.getElementById("elixirBar"); bar.innerHTML=""; for(let i=0;i<maxElixir;i++){ const seg=document.createElement("div"); seg.className="elixir-segment"; seg.id="elixir-"+i; bar.appendChild(seg); } }
function updateElixir(){ const now=Date.now(); if(now-lastElixirTime>=elixirRegenRate && elixir<maxElixir){ elixir++; lastElixirTime=now; } for(let i=0;i<maxElixir;i++){ const seg=document.getElementById("elixir-"+i); if(seg) seg.classList.toggle("elixir-filled", i<elixir); } }
setInterval(updateElixir,200);

function drawArena(){ const g=ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,getComputedStyle(document.documentElement).getPropertyValue('--bg-mid').trim()||"#123");
  g.addColorStop(.5,getComputedStyle(document.documentElement).getPropertyValue('--bg-dark').trim()||"#0b0f1c"); g.addColorStop(1,getComputedStyle(document.documentElement).getPropertyValue('--bg-mid').trim()||"#123");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#243a5e"; ctx.fillRect(0,RIVER_Y,canvas.width,RIVER_H);
  const bridges=[{x:BRIDGE_CENTERS[0]-BRIDGE_W/2,y:RIVER_Y-6},{x:BRIDGE_CENTERS[1]-BRIDGE_W/2,y:RIVER_Y-6}]; ctx.fillStyle="#6e5537";
  bridges.forEach(b=>{ ctx.fillRect(b.x,b.y,BRIDGE_W,RIVER_H+12); ctx.fillStyle="#7a6040"; for(let i=0;i<BRIDGE_W;i+=18) ctx.fillRect(b.x+i+2,b.y,8,RIVER_H+12); ctx.fillStyle="#6e5537"; });
  ctx.strokeStyle="rgba(255,255,255,0.15)"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0, canvas.height/3); ctx.lineTo(canvas.width, canvas.height/3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, canvas.height*2/3); ctx.lineTo(canvas.width, canvas.height*2/3); ctx.stroke();
  ctx.fillStyle="rgba(0,0,255,0.05)"; ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
  ctx.fillStyle="rgba(255,0,0,0.05)"; ctx.fillRect(0, 0, canvas.width, canvas.height/2);
  ctx.save(); ctx.globalAlpha=0.08;
  if(pocketBlue.left)  { ctx.fillStyle="#00ffff"; ctx.fillRect(0, 0, canvas.width/2, canvas.height/2); }
  if(pocketBlue.right) { ctx.fillStyle="#00ffff"; ctx.fillRect(canvas.width/2, 0, canvas.width/2, canvas.height/2); }
  if(pocketRed.left)   { ctx.fillStyle="#ff7f7f"; ctx.fillRect(0, canvas.height/2, canvas.width/2, canvas.height/2); }
  if(pocketRed.right)  { ctx.fillStyle="#ff7f7f"; ctx.fillRect(canvas.width/2, canvas.height/2, canvas.width/2, canvas.height/2); }
  ctx.restore();
}

function drawTower(t){ const size=t.king?60:50; ctx.fillStyle=t.side==="blue"?"#5ec8ff":"#ff6b6b"; ctx.fillRect(t.x-size/2,t.y-size/2,size,size);
  const maxHp=t.king?1000:600; ctx.fillStyle="#900"; ctx.fillRect(t.x-28,t.y-(size/2)-10,56,6); ctx.fillStyle="#3f3"; ctx.fillRect(t.x-28,t.y-(size/2)-10,56*(Math.max(0,t.hp)/maxHp),6); }
function drawTowerName(t,nm){ if(!nm) return; ctx.font='16px Arial'; ctx.textAlign='center'; ctx.lineWidth=3; ctx.strokeStyle='black'; const size=t.king?60:50;
  const y=t.side==='blue'?(t.y+size/2+18):(t.y-size/2-14); ctx.strokeText(nm,t.x,y); ctx.fillStyle='white'; ctx.fillText(nm,t.x,y); }
function drawUnit(u){ ctx.fillStyle=(u.side==="blue")?"#8de1ff":"#ff7f7f"; ctx.beginPath(); ctx.arc(u.x,u.y,14,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#900"; ctx.fillRect(u.x-15,u.y-24,30,5); ctx.fillStyle="#3f3"; ctx.fillRect(u.x-15,u.y-24,30*(u.hp/u.maxHp),5); }

function renderHandBar(){ const bar=document.getElementById("cardBar"); bar.innerHTML="";
  const toShow = handQueue.slice(0,4);
  toShow.forEach(nm=>{ const card=allCards.find(c=>c.name===nm); if(!card) return; const lvl=Math.max(1,Math.min(MAX_LEVEL,(playerLevels && playerLevels[nm])||1));
    const d=document.createElement("div"); d.className="card"; d.innerHTML=`<div class="elixir-cost">${card.cost}</div><div class="level-badge">Lv ${lvl}</div><img src="${card.img}"><b>${card.name}</b>`;
    const now=Date.now(); const cd=cardCooldowns[card.name]||0; if(cd>now) d.classList.add("cooldown");
    d.onclick=()=>{ if((cardCooldowns[card.name]||0)>Date.now()) return; selectedCard=card; document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected")); d.classList.add("selected"); showPlacementCircle(); };
    bar.appendChild(d);
  });
}
function showPlacementCircle(){
  let y=lastMouse.y;
  if(!selectedCard) return;
  if(selectedCard.type==="spell") placementCircle={x:lastMouse.x,y:lastMouse.y};
  else{
    if(mySide==="blue"){
      if(y<canvas.height/2) y=canvas.height/2;
    } else {
      if(y>canvas.height/2) y=canvas.height/2;
    }
    placementCircle={x:lastMouse.x,y};
  }
}
function refreshCooldownStyles(){ const now=Date.now(); document.querySelectorAll("#cardBar .card").forEach(el=>{ const nm=el.querySelector("b")?.textContent; if(!nm) return; el.classList.toggle("cooldown",(cardCooldowns[nm]||0)>now); }); }

function laneFromX(x){ return x<canvas.width/2 ? "left" : "right"; }
function clampPlacement(x,y,card){
  if(card && card.type==="spell") return {x:Math.max(20,Math.min(canvas.width-20,x)), y:Math.max(20,Math.min(canvas.height-20,y))};
  let nx=x, ny=y;
  if(mySide==="blue"){
    if(ny<canvas.height/2) {
      const lane = laneFromX(nx);
      if(!(lane==="left" ? pocketBlue.left : pocketBlue.right)) ny=canvas.height/2;
    }
  } else {
    if(ny>canvas.height/2) {
      const lane = laneFromX(nx);
      if(!(lane==="left" ? pocketRed.left : pocketRed.right)) ny=canvas.height/2;
    }
  }
  nx=Math.max(20,Math.min(canvas.width-20,nx)); ny=Math.max(20,Math.min(canvas.height-20,ny)); return {x:nx,y:ny};
}

const canvasEl = document.getElementById("battleCanvas");
canvasEl.addEventListener("mousemove",e=>{ const r=canvasEl.getBoundingClientRect(); lastMouse.x=e.clientX-r.left; lastMouse.y=e.clientY-r.top; if(!selectedCard){ placementCircle=null; return; } if(selectedCard.type==="spell") placementCircle={x:lastMouse.x,y:lastMouse.y}; else placementCircle=clampPlacement(lastMouse.x,lastMouse.y,selectedCard); });
canvasEl.addEventListener("click",e=>{ if(!battleReady||!selectedCard) return; const rect=canvasEl.getBoundingClientRect(); let x=e.clientX-rect.left,y=e.clientY-rect.top;
  const clamped = clampPlacement(x,y,selectedCard); x=clamped.x; y=clamped.y;
  if(elixir < selectedCard.cost) return;
  elixir -= selectedCard.cost; cardCooldowns[selectedCard.name]=Date.now()+5000; refreshCooldownStyles();
  db.ref("rooms/"+roomId+"/actions").push({player:playerId, card:selectedCard, x, y, timestamp:Date.now()});
  const idx=handQueue.indexOf(selectedCard.name); if(idx>-1){ const used=handQueue.splice(idx,1)[0]; handQueue.push(used); renderHandBar(); }
  selectedCard=null; placementCircle=null; document.querySelectorAll("#cardBar .card").forEach(c=>c.classList.remove("selected"));
});

function nearestEnemyUnit(u,maxR=9999){ let best=null,bestD2=Infinity; const r2=maxR*maxR; for(const v of units){ if(v.side===u.side||v.hp<=0||v===u) continue; const dx=v.x-u.x, dy=v.y-u.y; const d2=dx*dx+dy*dy; if(d2<=r2 && d2<bestD2){ best=v; bestD2=d2; } } return best; }
function nearestEnemyTower(u){ let best=null,bestD2=Infinity; for(const t of towers){ if(t.side===u.side||t.hp<=0) continue; const dx=t.x-u.x, dy=t.y-u.y; const d2=dx*dx+dy*dy; if(d2<bestD2){ best=t; bestD2=d2; } } return best; }

function pickNearestBridgeX(x){ const a=BRIDGE_CENTERS[0], b=BRIDGE_CENTERS[1]; return (Math.abs(x-a)<=Math.abs(x-b))?a:b; }

function spawnSkeletonHorde(side,x,y,ownerId,baseCard){
  const lvl=(roomLevelsCache[ownerId] && roomLevelsCache[ownerId][baseCard.name])||1; const mult=levelMultiplier(lvl);
  const count=14; const baseRadius=32;
  const swarmId = "swarm-"+Math.random().toString(36).slice(2,8);
  for(let i=0;i<count;i++){ const ang=(i/count)*Math.PI*2; const jitter=(Math.random()*10-5);
    const sx=x+Math.cos(ang)*(baseRadius+jitter); const sy=y+Math.sin(ang)*(baseRadius+jitter);
    units.push({
      name:"Skeleton", swarm:swarmId,
      hp: Math.max(1, Math.floor(baseCard.hp * 0.8 * mult)),
      maxHp: Math.max(1, Math.floor(baseCard.maxHp * 0.8 * mult)),
      dmg: Math.max(1, Math.floor(baseCard.dmg * 1.0 * mult)),
      range: 20, speed: Math.max(0.7, baseCard.speed*0.95),
      side, x:sx, y:sy, cooldown:0,
      pathStage:'toBridge', targetX: pickNearestBridgeX(x), targetY: (side==='blue' ? (RIVER_Y + RIVER_H + 8) : (RIVER_Y - 8)),
      level:lvl
    });
  }
}

function spawnUnit(card, side, x, y, ownerId){
  if(card.type==="spell") return;
  if(card.name==="Skeleton Army") return spawnSkeletonHorde(side,x,y,ownerId,card);
  const lvl=(roomLevelsCache[ownerId] && roomLevelsCache[ownerId][card.name])||1; const mult=levelMultiplier(lvl);
  const slowFactor=0.30; const speed=Math.max(0.35, card.speed*slowFactor);
  const bridgeX=pickNearestBridgeX(x); const startTargetY= side==='blue' ? (RIVER_Y + RIVER_H + 8) : (RIVER_Y - 8);
  units.push({
    name:card.name, hp:Math.floor(card.hp*mult), maxHp:Math.floor(card.maxHp*mult), dmg:Math.max(1,Math.floor(card.dmg*mult)), range:card.range,
    speed, side, x, y, cooldown:0,
    pathStage:'toBridge', targetX:bridgeX, targetY:startTargetY, level:lvl
  });
}

function castSpell(card,side,x,y,ownerId){
  const lvl=(roomLevelsCache[ownerId] && roomLevelsCache[ownerId][card.name])||1; const mult=levelMultiplier(lvl);
  const dmg=Math.floor((card.dmg||0)*mult); const rad=card.radius||80;
  for(const u of units){ if(u.side===side||u.hp<=0) continue; const dx=u.x-x, dy=u.y-y; if(dx*dx+dy*dy <= rad*rad) u.hp -= dmg; }
  const towerDmg=Math.floor(dmg*0.35); for(const t of towers){ if(t.side===side||t.hp<=0) continue; const dx=t.x-x, dy=t.y-y; if(dx*dx+dy*dy <= (rad+25)*(rad+25)) t.hp -= towerDmg; }
}

function moveTowards(u,tx,ty){ const dx=tx-u.x, dy=ty-u.y; const dist=Math.hypot(dx,dy); if(dist<=u.speed){ u.x=tx; u.y=ty; return true; } u.x += u.speed*dx/dist; u.y += u.speed*dy/dist; return false; }

function applySeparation(){
  const desired=22, maxPush=0.8;
  for(let i=0;i<units.length;i++){ const a=units[i]; if(!a.swarm) continue;
    for(let j=i+1;j<units.length;j++){ const b=units[j]; if(!b.swarm || b.swarm!==a.swarm) continue;
      const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy); if(d>0 && d<desired){ const push=(desired-d)/desired * maxPush; const nx=dx/d, ny=dy/d;
        a.x -= nx*push; a.y -= ny*push; b.x += nx*push; b.y += ny*push;
      }
    }
  }
}

function nearestEnemyTowerFor(u){ let best=null,bestD2=Infinity; for(const t of towers){ if(t.side===u.side||t.hp<=0) continue; const dx=t.x-u.x, dy=t.y-u.y; const d2=dx*dx+dy*dy; if(d2<bestD2){ best=t; bestD2=d2; } } return best; }

function updateUnits(){
  applySeparation();
  units.forEach(u=>{
    if(u.pathStage==='toBridge'){ if(moveTowards(u,u.targetX,u.targetY)){ u.pathStage='crossing'; u.targetY=(u.side==='blue')?(RIVER_Y-8):(RIVER_Y+RIVER_H+8); } return; }
    if(u.pathStage==='crossing'){ const enemyClose=nearestEnemyUnit(u, Math.max(140,u.range||25)+40);
      if(enemyClose){ const dx=enemyClose.x-u.x, dy=enemyClose.y-u.y; const dist=Math.hypot(dx,dy); const attackRange=Math.max(20,u.range||25);
        if(dist<=attackRange){ if(u.cooldown<=0){ enemyClose.hp -= u.dmg; u.cooldown=30; } } else moveTowards(u, enemyClose.x, enemyClose.y);
        if(u.cooldown>0) u.cooldown--; return; }
      if(moveTowards(u,u.targetX,u.targetY)) u.pathStage='toTarget'; return;
    }
    let target=nearestEnemyUnit(u,9999); if(!target||target.hp<=0) target=nearestEnemyTowerFor(u); if(!target) return;
    const dx=target.x-u.x, dy=target.y-u.y, dist=Math.hypot(dx,dy), attackRange=Math.max(20,u.range||25);
    if(dist<=attackRange){ if(u.cooldown<=0){ target.hp -= u.dmg; u.cooldown=30; } }
    else moveTowards(u,target.x,target.y);
    if(u.cooldown>0) u.cooldown--;
  });
  units = units.filter(u=>u.hp>0);
}

function updateTowersAI(){
  towers.forEach(t=>{ if(t.hp<=0) return; t.cd=Math.max(0,(t.cd||0)-1); const range=t.range||(t.king?250:200); if(t.cd>0) return;
    let best=null,bestD2=Infinity; for(const u of units){ if(u.side===t.side) continue; const dx=u.x-t.x, dy=u.y-t.y; const d2=dx*dx+dy*dy; if(d2<range*range && d2<bestD2){ best=u; bestD2=d2; } }
    if(best){ const speed=7; const dx=best.x-t.x, dy=best.y-t.y; const mag=Math.max(.001,Math.hypot(dx,dy)); const vx=speed*dx/mag, vy=speed*dy/mag;
      projectiles.push({x:t.x,y:t.y,vx,vy,dmg:(t.dmg||(t.king?26:16)),side:t.side}); t.cd=t.cdMax||60; }
  });
}
function updateProjectiles(){ const radius=5; projectiles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; for(const u of units){ if(u.side===p.side) continue; const dx=u.x-p.x, dy=u.y-p.y;
    if(dx*dx+dy*dy <= (radius+12)*(radius+12)){ u.hp -= p.dmg; p.dead=true; } } if(p.x<-20||p.x>canvas.width+20||p.y<-20||p.y>canvas.height+20) p.dead=true; });
  projectiles=projectiles.filter(p=>!p.dead);
}

function checkPocketUnlocks(){
  const redLeft  = towers.find(t=>t.side==="red" && !t.king && t.x<canvas.width/2);
  const redRight = towers.find(t=>t.side==="red" && !t.king && t.x>=canvas.width/2);
  const blueLeft = towers.find(t=>t.side==="blue" && !t.king && t.x<canvas.width/2);
  const blueRight= towers.find(t=>t.side==="blue" && !t.king && t.x>=canvas.width/2);
  pocketBlue.left  = redLeft && redLeft.hp<=0;
  pocketBlue.right = redRight&& redRight.hp<=0;
  pocketRed.left   = blueLeft&& blueLeft.hp<=0;
  pocketRed.right  = blueRight&& blueRight.hp<=0;
}

function endGame(winnerColor){
  if(gameOver) return; gameOver=true; roomRef.child("state").set("ended"); roomRef.child("winner").set(winnerColor);
  const iWon=(winnerColor==="Blue" && mySide==="blue") || (winnerColor==="Red" && mySide==="red");
  if(iWon){ playerRef.child("coins").transaction(c=>(c||0)+100); playerRef.child("trophies").transaction(t=>(t||0)+5); }
  document.getElementById("resultText").innerText=iWon?"üèÜ Victory!":"‚ùå Defeat";
  document.getElementById("rewardText").innerText=iWon?"+100 Coins, +5 Trophies":"Better luck next time!";
  document.getElementById("resultScreen").style.display="block";
}

function tieBreakOrTwoX(){
  const redLaneAlive = towers.filter(t=>t.side==="red" && !t.king).filter(t=>t.hp>0).length;
  const blueLaneAlive= towers.filter(t=>t.side==="blue"&& !t.king).filter(t=>t.hp>0).length;
  const redLostOne = redLaneAlive<=1;
  const blueLostOne= blueLaneAlive<=1;
  const blueIntact = blueLaneAlive===2;
  const redIntact  = redLaneAlive===2;
  const blueWins = redLostOne && blueIntact;
  const redWins  = blueLostOne && redIntact;
  if(blueWins && !redWins) return endGame("Blue");
  if(redWins && !blueWins) return endGame("Red");
  twoX=true; elixirRegenRate=Math.max(300, Math.floor(elixirRegenRate/2));
  const banner=document.getElementById("banner"); banner.textContent="2√ó ELIXIR"; banner.style.display="block"; setTimeout(()=>banner.style.display="none",1800);
}

function updateTimerUI(){
  if(!timerRunning) return;
  const left = Math.max(0, twoMinutes - (Date.now()-matchStartTs));
  const sec = Math.floor(left/1000); const m = String(Math.floor(sec/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0');
  document.getElementById("matchTimer").textContent = m+":"+s;
  if(left<=0) document.getElementById("matchTimer").textContent = "00:00";
}

function mainLoop(ts){
  drawArena(); towers.forEach(drawTower);
  const kBlue=towers.find(t=>t.side==="blue"&&t.king); const kRed=towers.find(t=>t.side==="red"&&t.king);
  if(kBlue) drawTowerName(kBlue, nameBlue); if(kRed) drawTowerName(kRed, nameRed);
  if(isHost && !gameOver){ updateTowersAI(); updateUnits(); updateProjectiles(); checkPocketUnlocks();
    for(const t of towers){ if(t.hp<=0 && t.king){ const w=(t.side==="blue")?"Red":"Blue"; endGame(w); break; } }
    if(ts-lastPublishTime>=PUBLISH_MS){ lastPublishTime=ts; stateRef.set({
      towers: towers.map(t=>({x:t.x,y:t.y,hp:t.hp,side:t.side,king:!!t.king})),
      units:  units.map(u=>({x:u.x,y:u.y,hp:u.hp,maxHp:u.maxHp,side:u.side,name:u.name,level:u.level||1}))
    }); }
    if(timerRunning){ const left = twoMinutes - (Date.now()-matchStartTs); if(left<=0){ timerRunning=false; tieBreakOrTwoX(); } }
  }
  projectiles.forEach(p=>{ ctx.fillStyle="#ffd86b"; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); });
  units.forEach(drawUnit);
  if(placementCircle && selectedCard){ ctx.beginPath(); ctx.arc(placementCircle.x,placementCircle.y,24,0,Math.PI*2); ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.stroke(); }
  updateTimerUI();
  if(!gameOver) requestAnimationFrame(mainLoop);
}

function preloadLevelsForRoom(){ if(!roomRef) return; roomRef.child("players").once("value").then(async pSnap=>{ const ids=[]; pSnap.forEach(ch=>ids.push(ch.key));
  await Promise.all(ids.map(async id=>{ const lvSnap=await db.ref("players/"+id+"/levels").once("value"); roomLevelsCache[id]=lvSnap.val()||{}; })); }); }
async function loadRoomNames(){ const playersSnap=await roomRef.child("players").once("value"); let blueId=null,redId=null;
  playersSnap.forEach(ch=>{ const v=ch.val(); if(!v) return; if(v.side==="blue") blueId=ch.key; if(v.side==="red") redId=ch.key; });
  const [bNameSnap,rNameSnap]=await Promise.all([db.ref("players/"+blueId+"/name").once("value"), db.ref("players/"+redId+"/name").once("value")]);
  nameBlue=bNameSnap.val()||"Blue"; nameRed=rNameSnap.val()||"Red";
}

function attachHostListeners(){
  actionsRef.on("child_added", snap=>{ const key=snap.key; if(pendingActionKeys.has(key)) return; pendingActionKeys.add(key);
    const a=snap.val(); const side=(a.player===playerId)?mySide:(mySide==="blue"?"red":"blue");
    let x=a.x, y=a.y;
    if(a.card && a.card.type!=="spell"){ const lane = x<canvas.width/2?"left":"right";
      if(side==="blue"){ if(y<canvas.height/2 && !(lane==="left"?pocketBlue.left:pocketBlue.right)) y=canvas.height/2; }
      else             { if(y>canvas.height/2 && !(lane==="left"?pocketRed.left:pocketRed.right)) y=canvas.height/2; }
    }
    if(a.card && a.card.type==="spell") castSpell(a.card,side,x,y,a.player); else spawnUnit(a.card,side,x,y,a.player);
  });
}
function attachClientStateListener(){ stateRef.on("value", snap=>{ const st=snap.val(); if(!st) return; towers=(st.towers||[]).map(t=>({...t})); units=(st.units||[]).map(u=>({...u})); }); }

function setupRoomAutoCleanup(){ roomRef.child("state").on("value", s=>{ if(s.val()==="ended"){ setTimeout(()=>{ roomRef.remove(); },15000); } });
  roomPlayersRef.on("value", s=>{ let any=false; s.forEach(p=>{ if(p.val() && p.val().connected) any=true; }); if(!any) setTimeout(()=>{ roomRef.remove(); },8000); }); }

function startBattle(){
  searching=false; db.ref("queue/"+playerId).remove(); if(pairInterval){clearInterval(pairInterval);pairInterval=null;}
  document.getElementById("menuScreen").style.display="none"; document.getElementById("battleScreen").style.display="block";
  document.getElementById("cardBar").style.display="flex"; document.getElementById("elixirBar").style.display="flex"; document.getElementById("emoteTray").style.display="flex";
  document.getElementById("statusText").innerText="In Battle (waiting for opponent‚Ä¶)";
  roomRef = db.ref("rooms/"+roomId); actionsRef=roomRef.child("actions"); stateRef=roomRef.child("authoritativeState"); roomPlayersRef=roomRef.child("players"); emoteRef=roomRef.child("emotes");
  roomRef.child("host").transaction(v=>v||playerId);
  roomRef.child("host").on("value", snap=>{ hostId=snap.val(); isHost=(hostId===playerId); if(isHost){ if(stateRef) stateRef.off(); attachHostListeners(); } else { if(actionsRef) actionsRef.off(); attachClientStateListener(); } });
  roomRef.child("players/"+playerId).update({connected:true,side:mySide,name:playerName});
  roomRef.child("players/"+playerId).onDisconnect().update({connected:false,lastSeen:firebase.database.ServerValue.TIMESTAMP});
  roomPlayersRef.once("value").then(s=>{ let connected=0; s.forEach(p=>{ if(p.val() && p.val().connected) connected++; }); battleReady=(connected>=2);
    document.getElementById("statusText").innerText=battleReady?"In Battle":"In Battle (waiting for opponent‚Ä¶)"; });
  roomPlayersRef.on("value", s=>{ let connected=0, hostConnected=false; s.forEach(p=>{ const v=p.val(); if(!v) return; if(v.connected) connected++; if(p.key===hostId) hostConnected=!!v.connected; }); battleReady=(connected>=2);
    document.getElementById("statusText").innerText=battleReady?"In Battle":"In Battle (waiting for opponent‚Ä¶)"; if(!hostConnected && battleReady && hostId!==playerId) roomRef.child("host").transaction(v=>v||playerId); });
  loadRoomNames(); preloadLevelsForRoom();
  elixir=5; lastElixirTime=Date.now(); initElixirBar();
  towers=[
    {x:200,y:560,hp:600,side:"blue",king:false,range:200,dmg:16,cdMax:60},
    {x:600,y:560,hp:600,side:"blue",king:false,range:200,dmg:16,cdMax:60},
    {x:400,y:640,hp:1000,side:"blue",king:true, range:250,dmg:26,cdMax:60},
    {x:200,y:140,hp:600,side:"red", king:false,range:200,dmg:16,cdMax:60},
    {x:600,y:140,hp:600,side:"red", king:false,range:200,dmg:16,cdMax:60},
    {x:400,y:60, hp:1000,side:"red", king:true, range:250,dmg:26,cdMax:60}
  ];
  units=[]; projectiles=[]; gameOver=false; selectedCard=null; placementCircle=null; battleReady=false; pendingActionKeys.clear();
  pocketBlue={left:false,right:false}; pocketRed={left:false,right:false};
  playerRef.child("deck").once("value").then(s=>{ const d=s.val()||ensureInitialDeck(playerOwned);
    handQueue = d.filter(nm=>playerOwned[nm]); while(handQueue.length<4){
      for(const nm in playerOwned) if(!handQueue.includes(nm)) handQueue.push(nm); if(handQueue.length>=4) break; else break;
    } renderHandBar();
  });
  if(isHost){ matchStartTs=Date.now(); timerRunning=true; twoX=false; roomRef.child("meta").update({startAt:matchStartTs}); }
  setupEmotes();
  setupRoomAutoCleanup();
  roomRef.child("winner").on("value", snap=>{ const w=snap.val(); if(!w || gameOver) return; const iWon=(w==="Blue"&&mySide==="blue")||(w==="Red"&&mySide==="red");
    gameOver=true; document.getElementById("resultText").innerText=iWon?"üèÜ Victory!":"‚ùå Defeat"; document.getElementById("rewardText").innerText=iWon?"+100 Coins, +5 Trophies":"Better luck next time!"; document.getElementById("resultScreen").style.display="block"; });
  requestAnimationFrame(mainLoop);
}
function returnToMenu(){
  document.getElementById("resultScreen").style.display="none"; document.getElementById("battleScreen").style.display="none"; document.getElementById("menuScreen").style.display="block";
  document.getElementById("cardBar").style.display="none"; document.getElementById("elixirBar").style.display="none"; document.getElementById("emoteTray").style.display="none"; document.getElementById("statusText").innerText="Idle";
  if(actionsRef) actionsRef.off(); if(stateRef) stateRef.off(); if(roomPlayersRef) roomPlayersRef.off(); if(roomRef) roomRef.child("host").off(); if(emoteRef) emoteRef.off();
  placementCircle=null; selectedCard=null; gameOver=false; roomId=null; mySide=null; searching=false; battleReady=false; queueAdded=false; isHost=false; hostId=null;
  playerRef.child("ownedCards").off();
}

/* ==== Emotes (both players) ==== */
function setupEmotes(){
  const tray=document.getElementById("emoteTray"); tray.querySelectorAll(".emote-btn").forEach(btn=>{
    btn.onclick=()=>{ if(emoteCooldown> Date.now()) return; emoteCooldown=Date.now()+900;
      const emote=btn.dataset.emote; emoteRef.push({from:playerId,emote,t:Date.now()});
    };
  });
  emoteRef.on("child_added", snap=>{ const v=snap.val()||{}; const em=v.emote||"üòÄ";
    const kBlue=towers.find(t=>t.side==="blue"&&t.king); const kRed=towers.find(t=>t.side==="red"&&t.king);
    if(kBlue) showEmoteBubble(kBlue.x,kBlue.y,em); if(kRed) showEmoteBubble(kRed.x,kRed.y,em);
  });
}
function showEmoteBubble(x,y,em){
  const r=document.getElementById("battleCanvas").getBoundingClientRect(); const el=document.createElement("div"); el.className="emote-bubble"; el.textContent=em;
  el.style.left=(r.left+x)+"px"; el.style.top=(r.top+y)+"px"; document.body.appendChild(el); setTimeout(()=>el.remove(),1300);
}
</script>


</body></html>
